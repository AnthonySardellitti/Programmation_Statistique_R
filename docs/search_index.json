[
["entrainement.html", "Chapitre 12 S’entrainer 12.1 TP1 12.2 TP2 12.3 TP3", " Chapitre 12 S’entrainer 12.1 TP1 Ce TP reprend les notions évoquées dans les chapitres 2 et 3. On utilise le dataset mtcars qui décrit les statistiques de voitures. Le dataset est présent dans le package datasets automatiquement installé sur R. Voici une description des données : mpg : Miles/(US) gallon cyl : Number of cylinders disp : Displacement (cu.in.) hp : Gross horsepower drat : Rear axle ratio wt : Weight (1000 lbs) qsec : 1/4 mile time vs : Engine (0 = V-shaped, 1 = straight) am : Transmission (0 = automatic, 1 = manual) gear : Number of forward gears carb : Number of carburetors mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Exercice 1 : Préparer son environnement de travail Dupliquer le dataset dans un nouvel objet appelé df. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Affichez le nom des colonnes Affichez le type des colonnes avec la fonction adaptée. On souhaite analyser les variables cyl, vs, am, gear et carb en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Combien de niveaux (levels) sont présents dans ces variables ? Affichez un résumé des données avec la fonction adaptée. Exercice 2 : Statistiques descriptives Déterminer la moyenne de la variable mpg Déterminer le maximum la variable wt. Déterminer la médiane de la variable hp. Déterminer les quartiles de la variable qsec. Déterminer les déciles de la variable qsec. Déterminer la variance et l’écart-type de la variable qsec. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variables factor. Exercice 3 : Quelques graphiques Contruire un histogramme de la distribution de la variable qsec. Constuire une boîte à moustache de la distribution de la variable qsec. Construire un diagramme en barre de répartition de la variable carb. Construire un diagramme circulaire de la répartition de la variable vs. Exercice 4 : Création de nouvelles colonnes La colonne mpg correspond au nombre de miles parcouru en 1 gallon (US). Cette mesure correspond en quelques sortes à la mesure de consommation de litres aux 100 km utilisée en France. Créer une colonne supplémentaire appelée litres_au_100km qui correspond à la conversion de la variable mpg(Miles/(US) gallon) en nombre de litres aux 100 kilomètres. Aidez-vous du guide des conversion disponible sur ce lien. Construire une nouvelle colonne appelée qsec_cut qui est un découpage de la variable qsec en 3 groupes (pas de restriction sur le nombre de classe). Construire une nouvelle colonne appelée litres100km_group pour distinguer deux groupes de voiture : celles qui consomment plus que la moyenne et celles qui consomment moins que la moyenne. 12.2 TP2 Ce TP reprend les notions évoquées dans les chapitres 2 à 5. On utilise le fichier pokemon.xlsx qui décrit les statistiques des pokemon des deux premières générations. Le fichier est issu du site Kaggle. Il a été adapté pour ce TP. Pour réaliser ce TP, télécharger le fichier en cliquant ici.Voici une description des données : pokedex_number : numéro du pokemon nom : nom du pokemon generation : le numéro de génération dont est issu le pokemon is_legendary : Oui / Non si le pokemon est légendaire type : le type du pokemon weight_kg : le poids du pokemon en kg height_m : la taille du pokemon en mètre attack : la puissance d’attaque du pokemon defense : la puissance de défense du pokemon speed : la vitesse du pokemon pokedex_number nom generation is_legendary type weight_kg height_m attack defense speed 1 Bulbizarre 1 Non grass 6.9 0.7 49 49 45 2 Herbizarre 1 Non grass 13.0 1.0 62 63 60 3 Florizarre 1 Non grass 100.0 2.0 100 123 80 4 Salameche 1 Non fire 8.5 0.6 52 43 65 5 Reptincel 1 Non fire 19.0 1.1 64 58 80 6 Dracaufeu 1 Non fire 90.5 1.7 104 78 100 7 Carapuce 1 Non water 9.0 0.5 48 65 43 8 Carabaffe 1 Non water 22.5 1.0 63 80 58 9 Tortank 1 Non water 85.5 1.6 103 120 78 10 Chenipan 1 Non bug 2.9 0.3 30 35 45 11 Chrysacier 1 Non bug 9.9 0.7 20 55 30 12 Papilusion 1 Non bug 32.0 1.1 45 50 70 13 Aspicot 1 Non bug 3.2 0.3 35 30 50 14 Coconfort 1 Non bug 10.0 0.6 25 50 35 15 Dardargnan 1 Non bug 29.5 1.0 150 40 145 16 Roucool 1 Non normal 1.8 0.3 45 40 56 17 Roucoups 1 Non normal 30.0 1.1 60 55 71 18 Roucarnage 1 Non normal 39.5 1.5 80 80 121 19 Rattata 1 Non normal NA NA 56 35 72 20 Rattatac 1 Non normal NA NA 71 70 77 Exercice 1 : Importer les données Importez le jeu de données pokemon.xlsx à l’aide du package readxl. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ? Affichez le nom des colonnes. Affichez le type des colonnes avec la fonction adaptée. On souhaite analyser les variables generation, is_legendary, et type en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor. Combien de niveaux (levels) sont présents dans ces variables ? Affichez un résumé des données avec la fonction adaptée. Exercice 2 : Statistiques descriptives Déterminer la moyenne de la variable weight_kg. Déterminer la médiane de la variable weight_kg. Déterminer les quartiles de la variable height_m. Déterminer les déciles de la variable height_m. Déterminer la variance et l’écart-type de la variable weight_kg. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variable factor en triant chaque sortie par ordre décroissant. Exercice 3 : Tris et Selections Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple : #Selectionnez les deux premières colonnes du data frame requete_0 &lt;- pokemon[,1:2] dim(requete_0) ## [1] 251 2 Sélectionnez la colonne nom et is_legendary. Sélectionnez les 50 premières lignes et les deux premières colonnes. Sélectionnez les 10 premières lignes et toutes les colonnes. Sélectionnez toutes les colonnes sauf la dernière. Sélectionnez les colonnes 2,8,9 et 10. Sélectionnez les lignes 20 à 30 et 80 à 100. Triez le dataset par ordre alphabétique et afficher le nom du pokemon dela première ligne. Triez le dataset par weight_kg en ordre décroissant, et afficher le nomdu pokemon de la première ligne Triez le dataset par attack en ordre décroissant puis par speed en ordre croissant, et afficher le nom des pokemons des 10 premières lignes. Exercice 4 : Tris et Filtres Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Pour faciliter la lecture, sélectionnez la colonne nomet les colonnes concernées par le filtre. Exemple : #Selectionnez les pokemons de type feu requete_0 &lt;- pokemon[ pokemon$type == &quot;fire&quot;, c(&quot;nom&quot;,&quot;type&quot;)] dim(requete_0) ## [1] 20 2 Filtrez sur les pokemons qui ont 150 ou plus d’attack puis trier le résultat par ordre décroissant d’attack. Filtrez sur les pokemons de type dragon,ghost,psychic et dark Filtrez sur les pokemons de type fire avec plus de 100 d’attack, puis trier le résultat par ordre décroissant d’attack. Filtrez sur les pokemons qui ont entre 100 et 150 de speed. Les trier par speed décroissant. Filtrez sur les pokemons pesant plus de 250 kg et affichez le résultat pour vérifier. Filtrez sur les pokémons qui ont des valeurs manquantes sur la variable height_m. Filtrez sur les pokemons qui ont des valeurs renseignées à la fois pour la variable weight_kg et la variable height. Exercice 5 : Agregations Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple : #Calculez la vitesse moyenne par generation requete_0 &lt;- aggregate(formula = speed ~ generation, data = pokemon , FUN = mean) dim(requete_0) ## [1] 2 2 generation speed 1 70.15232 2 61.61000 Calculez l’attack moyenne en fonction de la variable type, puis filtrez sur les 3 types avec les moyennes les plus élevées. Calculez le nombre de pokemon par type , puis triez par ordre décroissant ces effectifs. Calculez la médiane de weight_kg par type. Calculez le nombre de pokemon par type et generation Calculez la moyenne de chaque critère (weight_kg, height_m, attack, defense et speed) en fonction de chaque type. 12.3 TP3 Ce TP reprend les notions évoquées dans les chapitres 6,7 et 10. On utilise le fichier compressé AmongUs.7z où l’ensemble des fichiers décrivent les statistiques des parties jouées sur le jeu Among Us. Il y a un fichier par joueur nommé UserX.csv. Les données sont issues du site Kaggle. Pour réaliser ce TP, télécharger le fichier en cliquant ici. Les fichiers csv ont tous la même structure avec : Game.Completed.Date : Date de la partie Team : l’équipe attribuée Outcome : résultat de la partie Task.Completed : le nombre de tâches effectuées All.Tasks.Completed : si toutes les tâches ont été effectuées Murdered : si le joueur a été tué Imposter.Kills : le nombre de joueurs tués par l’imposteur Game.Length : durée de la partie Ejected : si le joueur a été éliminé par les autres au cours de la partie Sabotages.Fixed : nombre de sabotages réparés Time.to.complete.all.tasks : temps pour compléter les toutes les tâches Rank.Change : Non renseigné Region.Game.Code : la région du serveur de jeu Game.Completed.Date Team Outcome Task.Completed All.Tasks.Completed Murdered Imposter.Kills Game.Length Ejected Sabotages.Fixed Time.to.complete.all.tasks Rank.Change Region.Game.Code 12/13/2020 at 1:26:56 am EST Crewmate Win 3 No Yes 07m 04s No 2 ++ NA / WYMSBF 12/13/2020 at 1:17:42 am EST Crewmate Loss 7 Yes No 16m 21s No 1 09m 48s – NA / WYMSBF 12/13/2020 at 12:57:47 am EST Crewmate Win 3 No No 11m 33s No 0 ++ NA / WYMSBF 12/13/2020 at 12:41:55 am EST Imposter Win 2 08m 05s No N/A +++ Europe / QIRTNF 12/13/2020 at 12:30:37 am EST Crewmate Loss 4 No No 05m 10s No 0 — Europe / QIRTNF 12/13/2020 at 12:24:20 am EST Crewmate Loss 7 Yes Yes 16m 22s No 0 12m 16s – Europe / QIRTNF 12/13/2020 at 12:00:39 am EST Crewmate Loss 8 Yes Yes 21m 41s No 1 18m 38s – Europe / MTKPVF 12/11/2020 at 4:15:08 pm EST Crewmate Win 8 Yes No 18m 43s Yes 0 07m 48s ++ Europe / BFRJCF 12/11/2020 at 3:49:33 pm EST Crewmate Win 7 Yes Yes 13m 15s No 0 13m 15s ++ Europe / BFRJCF 12/11/2020 at 3:30:36 pm EST Crewmate Loss 7 Yes Yes 12m 43s No 0 12m 43s – Europe / BFRJCF 12/11/2020 at 3:10:58 pm EST Crewmate Win 4 No Yes 11m 00s No 0 ++ Europe / BFRJCF 12/11/2020 at 2:53:28 pm EST Crewmate Win 7 Yes No 17m 43s No 0 11m 59s ++ Europe / BFRJCF 12/11/2020 at 2:20:38 pm EST Crewmate Loss 6 No Yes 13m 46s No 0 — Europe / ONSJWQ 12/11/2020 at 2:04:26 pm EST Imposter Loss 3 15m 52s Yes N/A Europe / ONSJWQ 12/11/2020 at 1:46:30 pm EST Crewmate Win 7 Yes Yes 18m 54s No 1 11m 09s ++ Europe / ONSJWQ 12/11/2020 at 2:09:32 am EST Crewmate Loss 7 Yes Yes 08m 00s No 0 01m 41s – NA / EYNONF 12/11/2020 at 2:00:26 am EST Crewmate Win 7 Yes Yes 18m 06s No 0 09m 34s ++ NA / EYNONF 12/11/2020 at 1:26:11 am EST Crewmate Win 7 Yes Yes 12m 58s No 1 09m 03s ++ NA / EYNONF 12/11/2020 at 1:03:05 am EST Crewmate Win 7 Yes Yes 14m 57s No 0 14m 50s ++ NA / EYNONF 12/11/2020 at 12:45:34 am EST Crewmate Loss 7 Yes Yes 11m 03s No 0 10m 34s – NA / EYNONF Exercice 1 : Créer le jeu de données Télécharger le fichier compressé AmongUs.7z et le déziper. La fonction list.files() devrait vous aider à extraire l’ensemble des noms de fichiers présents dans un répertoire (voir l’exemple ci-dessous). list.files(path = &quot;dataset/&quot;, pattern=&quot;*.csv&quot;, full.names=FALSE) ## [1] &quot;AmongUs.csv&quot; &quot;characters.csv&quot; &quot;flights.csv&quot; &quot;google.csv&quot; ## [5] &quot;NBA.csv&quot; &quot;planes.csv&quot; &quot;starwars.csv&quot; &quot;Titanic.csv&quot; Compiler l’ensemble des fichiers UserX.csv présents dans le fichier zip dans un seul et même data frame. Utiliser une boucle qui parcourt chaque fichier csv utilisateur. La fonction rbind() devrait vous aider à compiler les différents csv dans un seul data frame (voir l’exemple ci-dessous). 📢 Attention, pour le bon déroulement du TP, intégrer l’argument stringsAsFactors = FALSE dans votre fonction read.csv(). Cet argument permet de ne pas typer par défaut les variables character en factor lors de l’importation. df &lt;- data.frame() dim(df) ## [1] 0 0 df &lt;- rbind(df, mtcars) dim(df) ## [1] 32 11 df &lt;- rbind(df, mtcars) dim(df) ## [1] 64 11 Modifier votre boucle afin d’ajouter une colonne dans le data frame final qui renseigne le numéro d’utilisateur disponible dans le nom de chaque fichier csv. 💡 indice : Il est plus simple d’ajouter une colonne avec le nom du fichier juste avant la fonction rbind(). Stocker le data frame final dans un objet appelé AmongUs. Supprimer la colonne Rank.Change qui est inutile. On observe des valeurs manquantes dans le dataset à travers les champs - et N/A, on souhaite remplacer ces valeurs textuelles par la véritable valeur NA permettant d’indiquer à R que la valeur est manquante. Construire une fonction appelée manage_na() qui prend en entrée : un vecteur x correspondra à une colonne d’un dataset. un vecteur string_to_na correspondant à la liste des chaînes de caractères qu’on souhaite transformer en NA. La fonction retournera le vecteur modifié. 💡 indice : voici ci-dessous la tête que doit avoir votre fonction : manage_na &lt;- function(x, string_to_na) { ... ... ... return(x_modif) } Construire une boucle qui parcourt toutes les colonnes du data frame AmongUs et qui remplace les champs avec des - et N/A par des valeurs manquantes NA. Utilisez la fonction manage_na() créée précédemment. Exercice 2 : Manipuler le texte et les dates À partir de la colonne Game.Completed.Date, construire une colonne appelée Date avec la date de la partie au format yyyy-mm-dd uniquement. Veiller à ce que le type de cette colonne soit Date. À partir de la colonne Game.Completed.Date, construire une colonne appelée Heure avec l’heure uniquement de la partie. Attention au format am et pm. À partir de la colonne Game Length, construire une colonne appelée Game.Length.sec correspondant à la durée de la partie en secondes. À partir de la colonne Time.to.complete.all.tasks, construire une colonne appelée Complete.all.tasks.sec correspondant à la durée en secondes pour compléter toutes les tâches. À partir de la colonne Region.Game.Code construire une colonne appelée Region correspondant au nom du continent uniquement. Exercice 3 : Type des variables Combien de lignes, colonnes sont présentes dans ce dataset (Utiliser la fonction adaptée) ? Afficher un résumé des données avec la fonction adaptée. Veiller à ce que les types de chaque colonne du dataset correspondent aux types ci-dessous. Sinon, convertir les variables dans leur type approprié. Variable Type souhaité Game.Completed.Date character Team factor Outcome factor Task.Completed numeric All.Tasks.Completed factor Murdered factor Imposter.Kills numeric Game.Length character Ejected factor Sabotages.Fixed numeric Time.to.complete.all.tasks character Region.Game.Code character Date Date Heure numeric Game.Length.sec numeric Complete.all.tasks.sec numeric Region factor 📢 Attention, lorsqu’on convertit un vecteur de type factor en type numeric, il est recommandé de passer d’abord par le type character (voir exemple ci-dessous). Ce ne sera peu être pas utile pour ce TP, mais c’est bien de le savoir ! Ce qu’il ne faut pas faire ⛔ x &lt;- factor(c(7,7,8,7,9,6,6)) levels(x) ## [1] &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; x &lt;- as.numeric(x) x ## [1] 2 2 3 2 4 1 1 Ce qu’il faut faire ✅ x &lt;- factor(c(7,7,8,7,9,6,6)) levels(x) ## [1] &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; x &lt;- as.numeric(as.character(x)) x ## [1] 7 7 8 7 9 6 6 Vérifier si cela a fonctionné en affichant le type de chaque variable du data frame. Exercice 4 : Analyses statistiques La plupart des questions de cet exercice demandent un peu de réflexion. 📢 Ne partez pas à l’abordage, les solutions peuvent se coder en plusieurs étapes (tris,filtres, agregations, etc.). Quelle est la durée moyenne d’une partie ? Combien y-a-t-il de régions serveurs différentes ?. Combien de tâche maximum un Crewmate peut-il réaliser ? Quel est le taux de parties remportées par les imposteurs ? Construire un graphique adapté permettant de visualiser la répartition du nombre de parties jouées selon laRegion. Construire un graphique adapté permettant de visualiser la répartition des joueurs qui termine ou pas leurs tâches selon s’ils se font tuer ou pas. Construire un graphique adapté permettant de visualiser la distribution du nombre de tâches complétées par les joueurs. Construire un graphique adapté permettant de visualiser pour chaque partie jouée, la durée de la partie et le temps pour compléter toutes les tâches. Construire un graphique adapté permettant de visualiser la distribution du temps des parties selon la Region. Construire un graphique adapté permettant de visualiser l’évolution du nombre de parties jouées selon l’heure de la journée. Construire un graphique adapté permettant de visualiser les variations du taux de succès des imposteurs selon les régions serveurs. Construire un graphique adapté permettant de visualiser les taux de succès des 5 meilleurs utilisateurs. "]
]
