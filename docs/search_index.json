[
["index.html", "Programmation Statistique avec R 1 Préface", " Programmation Statistique avec R Anthony SARDELLITTI 2020-04-08 1 Préface Ce livre permet de mettre un pied dans le monde de la programmation statistique avec le langage R. Il présente les concepts fondamentaux. Certaines parties sont extraites d’autres sources qui seront renseignées. Il n’y a pas de pré-requis pour suivre ce livre. Seulement une apétence pour la programmation et les analyses statistiques. "],
["présentation.html", "2 Présentation 2.1 Introduction 2.2 Prise en main", " 2 Présentation Ce chapitre est extrait du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) 2.1 Introduction 2.1.1 À propos de R R est un langage orienté vers le traitement et l’analyse quantitative des données, dérivé du langage. Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une grande communauté d’utilisateurs. C’est un logiciel libre, publié sous licence GNU GPL. Utilisation de R présente plusieurs avantages: c’est un logiciel multiplateforme, qui fonctionne aussi bien sur des systèmes Linux, Mac OS X ou Windows. c’est un logiciel libre, développé par ses utilisateurs, diffusable et modifiable par tout un chacun. c’est un logiciel gratuit. c’est un logiciel très puissant, dont les fonctionnalités de base peuvent être étendues à l’aide d’extensions développées par la communauté. Il en existe plusieurs milliers. c’est un logiciel dont le développement est très actif et dont la communauté d’utilisateurs et l’utilisation ne cessent de grandir. c’est un logiciel avec des capacités graphiques intéressantes. Comme rien n’est parfait, on peut également trouver quelques inconvénients : le logiciel, la documentation de référence et les principales ressources sont en anglais. Il est cependant parfaitement possible d’utiliser R sans spécialement maîtriser cette langue et il existe de plus en plus de ressources francophones. R n’est pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à l’aide de scripts (des petits programmes) édités et exécutés au fur et à mesure de l’analyse. en tant que langage de programmation, R à la réputation d’être difficile d’accès, notamment pour ceux qui n’ont jamais été programmés auparavant. Au départ cantonné à la sphère universitaire, R est aujourd’hui de plus en plus utilisé dans des grandes entreprises et administrations, car il coûte beaucoup moins cher que ses concurrents (par exemple SAS) tout en étant très peformant. Ce document ne demande aucun prérequis en informatique ou en programmation. Juste un peu de motivation pour l’apprentissage du langage et, si possible, des données intéressantes sur l’application appliquée les connaissances acquiert. L’aspect langage de programmation et la difficulté qui en découle peut sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite d’instructions effectuant les différentes opérations d’une analyse) présente cependant de nombreux avantages : le script garde par ordre chronologique l’ensemble des étapes d’une analyse, des données des données à leur analyser en passant par les manipulations et les recodages. on peut à tout moment revenir en arrière et modifier ce qui a été fait. il est très rapide de réexécuter une suite d’opérations complexes. on peut très facilement mettre à jour les résultats en cas de modification des sources de données. le script garanti, sous certaines conditions, la reproductibilité des résultats obtenus. 2.1.2 À propos de RStudio RStudio n’est pas à proprement parler une interface graphique pour R, il s’agit plutôt d’un environnement de développement intégré, qui propose des outils et facilite l’écriture de scripts et l’usage de R au quotidien. C’est une interface bien supérieure à celles fournies par défaut fournies installe R sous Windows ou sous Mac ^ [Sous Linux R n’est fourni que comme un outil en ligne de commande.]. Pour paraphraser Hadrien Commenges, il n’y a pas d’obligation à utiliser RStudio, mais il y a une obligation à ne pas utiliser les interfaces de R par défaut. RStudio est également un logiciel libre et gratuit. Une version payante existe, mais elle ne propose pas de fonctionnalités indispensables. 2.1.3 À propos du tidyverse Le tidyverse est un ensemble d’extensions pour R (code développé par la communauté permettant de rajouter des fonctionnalités à R) construites autour d’une philosophie commune et exercé pour fonctionner ensemble. Elles facilitent l’utilisation de R dans les domaines les plus courants : manipulation des données, recodages, production de graphiques, etc. 2.1.4 Structure du document Ce document est composé de deux grandes fêtes : Une Introduction à R , qui présente les bases du langage R et de l’interface RStudio Une Introduction au tidyverse qui présente cet ensemble d’extensions pour la visualisation, la manipulation des données et l’export de résultats 2.1.5 Prérequis Le seul prérequis pour suivre ce document est installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour l’installateur R, il suffit de se rendre sur une des pages suivantes : Installer R sous Windows Installateur R sous Mac Pour l’installateur RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système https://www.rstudio.com/products/rstudio/download/#download 2.2 Prise en main Une fois R et RStudio installés sur votre machine, nous n’allons pas lancer R mais plutôt RStudio. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts. 2.2.1 La console 2.2.1.1 L’invite de commandes Au premier lancement de RStudio, l’écran principal est découpé en trois grandes zones : La zone de gauche se nomme Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui. La Console doit normalement afficher un texte de bienvenue ressemblant à ceci : R version 3.5.2 (2018-12-20) -- &quot;Eggshell Igloo&quot; Copyright (C) 2018 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R est un logiciel libre livré sans AUCUNE GARANTIE. Vous pouvez le redistribuer sous certaines conditions. Tapez &#39;license()&#39; ou &#39;licence()&#39; pour plus de détails. R est un projet collaboratif avec de nombreux contributeurs. Tapez &#39;contributors()&#39; pour plus d&#39;information et &#39;citation()&#39; pour la façon de le citer dans les publications. Tapez &#39;demo()&#39; pour des démonstrations, &#39;help()&#39; pour l&#39;aide en ligne ou &#39;help.start()&#39; pour obtenir l&#39;aide au format HTML. Tapez &#39;q()&#39; pour quitter R. suivi d’une ligne commençant par le caractère &gt; et sur laquelle devrait se trouver votre curseur. Cette ligne est appelée l’invite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine commande. Nous pouvons tout de suite lui fournir une première commande, en saisissant le texte suivant puis en appuyant sur Entrée : 2 + 2 ## [1] 4 R nous répond immédiatement, et nous pouvons constater avec soulagement qu’il sait faire des additions à un chiffre1. On peut donc continuer avec d’autres opérations : 5 - 7 ## [1] -2 4 * 12 ## [1] 48 -10 / 3 ## [1] -3.333333 5^2 ## [1] 25 Cette dernière opération utilise le symbole ^ qui représente l’opération puissance. 5^2 signifie donc “5 au carré”, soit 25. 2.2.1.2 Précisions concernant la saisie des commandes Lorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code. 10+2 10 + 2 10 + 2 Quand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut et vers le bas pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée. Enfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe + : 4 * + Cela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap. 2.2.2 Objets 2.2.2.1 Objets simples Faire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller. Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche. Prenons tout de suite un exemple : x &lt;- 2 Cette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”. Si on exécute une commande comportant juste le nom d’un objet, R affiche son contenu : x ## [1] 2 On voit donc que notre objet x contient bien la valeur 2. On peut évidemment réutiliser cet objet dans d’autres opérations. R le remplacera alors par sa valeur : x + 4 ## [1] 6 On peut créer autant d’objets qu’on le souhaite. x &lt;- 2 y &lt;- 5 resultat &lt;- x + y resultat ## [1] 7 Attention Les noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat. De manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets. De même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez explicite). Quand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire. x &lt;- 2 x &lt;- 5 x ## [1] 5 De la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche : x &lt;- 1 y &lt;- 3 x &lt;- y x ## [1] 3 ### Si on modifie y, cela ne modifie pas x y &lt;- 4 x ## [1] 3 On le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou \") : chien &lt;- &quot;Chihuahua&quot; chien ## [1] &quot;Chihuahua&quot; 2.2.2.2 Vecteurs Imaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien : taille1 &lt;- 156 taille2 &lt;- 164 taille3 &lt;- 197 taille4 &lt;- 147 taille5 &lt;- 173 (taille1 + taille2 + taille3 + taille4 + taille5) / 5 ## [1] 167.4 Cette manière de faire n’est évidemment pas pratique du tout. On va plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la fonction combine appeler avec le raccourci c : tailles &lt;- c(156, 164, 197, 147, 173) Si on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies : tailles ## [1] 156 164 197 147 173 Un vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre. L’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire : tailles_m &lt;- tailles / 100 tailles_m ## [1] 1.56 1.64 1.97 1.47 1.73 Cela fonctionne pour toutes les opérations de base : tailles + 10 ## [1] 166 174 207 157 183 tailles^2 ## [1] 24336 26896 38809 21609 29929 Imaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut alors créer un deuxième vecteur : poids &lt;- c(45, 59, 110, 44, 88) On peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré : imc &lt;- poids / (tailles / 100) ^ 2 imc ## [1] 18.49112 21.93635 28.34394 20.36189 29.40292 Un vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères. Une chaîne de caractère contient du texte libre, délimité par des guillemets simples ou doubles : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) diplome ## [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; L’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R : x &lt;- 1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 Enfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré. Par exemple : diplome[2] ## [1] &quot;Bac&quot; Cette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur. Dernière remarque, si on affiche dans la console un vecteur avec beaucoup d’éléments, ceux-ci seront répartis sur plusieurs lignes. Par exemple, si on a un vecteur de 50 nombres on peut obtenir quelque chose comme : [1] 294 425 339 914 114 896 716 648 915 587 181 926 489 [14] 848 583 182 662 888 417 133 146 322 400 698 506 944 [27] 237 324 333 443 487 658 793 288 897 588 697 439 697 [40] 914 694 126 969 744 927 337 439 226 704 635 On remarque que R ajoute systématiquement un nombre entre crochets au début de chaque ligne : il s’agit en fait de la position du premier élément de la ligne dans le vecteur. Ainsi, le 848 de la deuxième ligne est le 14e élément du vecteur, le 914 de la dernière ligne est le 40e, etc. Ceci explique le [1] qu’on obtient quand on affiche un simple nombre2 : [1] 4 On peut également effectuer une indexation multiple sur un vecteur si on souhaite sélectionner plusieurs élèments. diplome[c(2,3,4)] ## [1] &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; On peut également effectuer une indexation contraire sur un vecteur en précisant tous les élèments que l’on ne veut pas sélectionner. Pour cela, on utilise le ‘-’ devant l’indexation : diplome[-2] ## [1] &quot;CAP&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; diplome[- c(2,4)] ## [1] &quot;CAP&quot; &quot;Bac+2&quot; &quot;Bac+3&quot; 2.2.2.3 Type de vecteur Les vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent. On a ainsi des vecteurs de type numeric, character ou logical: numeric_vec &lt;- c(10,55,49,4) class(numeric_vec) ## [1] &quot;numeric&quot; character_vec &lt;- c(&quot;Jaune&quot;, &quot;Vert&quot;, &quot;Bleu&quot;, &quot;Rouge&quot;) class(character_vec) ## [1] &quot;character&quot; logical_vec &lt;- c(TRUE,FALSE,FALSE,TRUE) class(logical_vec) ## [1] &quot;logical&quot; Attention : dans un vecteur, tous les éléments sont de même type : un_vecteur &lt;- c(&quot;Luca&quot;, 30, 2000, FALSE) class(un_vecteur) ## [1] &quot;character&quot; un_vecteur ## [1] &quot;Luca&quot; &quot;30&quot; &quot;2000&quot; &quot;FALSE&quot; Il existe des fonctions pour tester la classe d’un vecteur. Elles s’écrivent avec le même préfixe is.classe_a_tester. Ces fonctions sont des tests logiques donc elles renvoient toujours des booléens. is.numeric(numeric_vec) ## [1] TRUE is.numeric(character_vec) ## [1] FALSE is.character(numeric_vec) ## [1] FALSE is.character(character_vec) ## [1] TRUE is.logical(logical_vec) ## [1] TRUE is.logical(character_vec) ## [1] FALSE Il est également possible de modifier la classe d’un vecteur avec les fonctions as.new_class. as.character(numeric_vec) ## [1] &quot;10&quot; &quot;55&quot; &quot;49&quot; &quot;4&quot; as.numeric(logical_vec) ## [1] 1 0 0 1 Dans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). En R, la classe factor est un vecteur contenant uniquement certaines valeurs prédéfinies. Ces valeurs pré-définies sont appelées des levels. diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) class(diplome) ## [1] &quot;character&quot; diplome &lt;- as.factor(diplome) diplome ## [1] CAP Bac Bac+2 CAP Bac+3 ## Levels: Bac Bac+2 Bac+3 CAP class(diplome) ## [1] &quot;factor&quot; Si on souhaite modifier ou ajouter un élèment avec une modalité qui n’est pas pris en compte dans les levels, nous allons avoir une erreur. diplome[6] &lt;- &quot;Master&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 6, value = &quot;Master&quot;): invalid factor ## level, NA generated diplome ## [1] CAP Bac Bac+2 CAP Bac+3 &lt;NA&gt; ## Levels: Bac Bac+2 Bac+3 CAP Il faut donc modifier les levels acceptés par le vecteur en amont. levels(diplome) &lt;- c(levels(diplome), &quot;Master&quot;) diplome[6] &lt;- &quot;Master&quot; diplome ## [1] CAP Bac Bac+2 CAP Bac+3 Master ## Levels: Bac Bac+2 Bac+3 CAP Master Mais à quoi peut servir tout cela ? En réalité, l’intérêt principal de la classe factor est de prendre moins de place en mémoire car les levels sont stockés en numeric. Si on transforme notre vecteur en classe numeric nous n’allons pas avoir d’erreur. class(diplome) ## [1] &quot;factor&quot; diplome &lt;- as.numeric(diplome) class(diplome) ## [1] &quot;numeric&quot; diplome ## [1] 4 1 2 4 3 5 On observe que les nombres obtenus correspondent aux numéros de levels. Il faut donc faire trés attention lorsqu’on veut passer une classe numeric à une variable quantitative importée en tant que factor. 2.2.3 Fonctions 2.2.3.1 Principe Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard. Pour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions. Formellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat. Prenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière : length(tailles) ## [1] 5 Ici, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoie un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre. Autre exemple, les fonctions min et max retournent respectivement les valeurs minimales et maximales d’un vecteur de nombres : min(tailles) ## [1] 147 max(tailles) ## [1] 197 La fonction mean calcule et retourne la moyenne d’un vecteur de nombres : mean(tailles) ## [1] 167.4 La fonction sum retourne la somme de tous les éléments du vecteur : sum(tailles) ## [1] 837 Jusqu’à présent on n’a vu que des fonctions qui calculent et retournent un unique nombre. Mais une fonction peut renvoyer d’autres types de résultats. Par exemple, la fonction range (étendue) renvoie un vecteur de deux nombres, le minimum et le maximum : range(tailles) ## [1] 147 197 Ou encore, la fonction unique, qui supprime toutes les valeurs en double dans un vecteur, qu’il s’agisse de nombres ou de chaînes de caractères : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) unique(diplome) ## [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;Bac+3&quot; 2.2.3.2 Arguments Une fonction peut prendre plusieurs arguments, dans ce cas on les indique toujours entre parenthèses, séparés par des virgules. On a déjà rencontré un exemple de fonction acceptant plusieurs arguments : la fonction c, qui combine l’ensemble de ses arguments en un vecteur3 : tailles &lt;- c(156, 164, 197, 181, 173) Ici, c est appelée en lui passant cinq arguments, les cinq tailles séparées par des virgules, et elle renvoie un vecteur numérique regroupant ces cinq valeurs. Supposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre). On symbolise celle-ci dans R avec le code interne NA : tailles &lt;- c(156, 164, 197, NA, 173) tailles ## [1] 156 164 197 NA 173 NA est l’abréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc. Si je calcule maintenant la taille moyenne à l’aide de la fonction mean, j’obtiens : mean(tailles) ## [1] NA En effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Il considère alors que cette moyenne est elle-même “non disponible” et renvoie donc comme résultat NA. On peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai) : mean(tailles, na.rm = TRUE) ## [1] 172.5 Positionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul. Si on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes : mean(tailles) ## [1] NA mean(tailles, na.rm = FALSE) ## [1] NA Lorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé. 2.2.3.3 Aide sur une fonction Il est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help : help(&quot;mean&quot;) ?mean On peut aussi utiliser le raccourci ?mean. Ces deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée. Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. 2.2.3.4 Programmer des fonctions Il est possible de programmer ses propres fonctions. Dans l’exemple ci-dessous on construit une fonction imcq ui prend en entrée deux arguments poids et taille. La fonction effectue un calcul et renvoi l’IMC. Pour construire une fonction, on doit obligatoirement faire appel au mot clé function. Le mot clé return n’est pas obligatoire. Cependant, par convention, une fonction renvoie toujours un résultat qui peut aussi être un message d’information sur le bon déroulement de celle-ci. Les arguments sont précisés entre parenthèses ( ). Les traitements s’effectuent entre accolades { }. imc &lt;- function(taille,poids) { calcul &lt;- poids / (taille^2) return (calcul) } Lorsqu’on vérifie la classe de l’objet imc en mémoire, on constate qu’il est bien de type function. class(imc) ## [1] &quot;function&quot; Puis c’est le même principe que les autres fonctions pour l’utiliser : imc(taille = 1.55, poids = 49) ## [1] 20.39542 Il est possible de préciser des arguments par défaut. Ils sont à saisir dans la définition des arguments : imc &lt;- function(taille = 1.70, poids = 60) { calcul &lt;- poids / (taille^2) return (calcul) } imc() ## [1] 20.76125 2.2.4 Regrouper ses commandes dans des scripts Jusqu’ici on a utilisé R de manière “interactive”, en saisissant des commandes directement dans la console. Ça n’est cependant pas la manière dont on va utiliser R au quotidien, pour une raison simple : lorsque R redémarre, tout ce qui a été effectué dans la console est perdu. Plutôt que de saisir nos commandes dans la console, on va donc les regrouper dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” les données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script. Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choisissant File puis Save. Un script est un fichier texte brut, qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne (comme on pouvait s’y attendre). Pour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup. Finalement, un script pourra ressembler à quelque chose comme ça : tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) mean(tailles) mean(poids) imc &lt;- poids / (tailles / 100) ^ 2 min(imc) max(imc) 2.2.4.1 Commentaires Les commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption. Pour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jusqu’à la fin de la ligne. On peut donc documenter le script précédent : # Saisie des tailles et poids des enquêtés tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) # Calcul des tailles et poids moyens mean(tailles) mean(poids) # Calcul de l&#39;IMC (poids en kilo divisé par les tailles en mètre au carré) imc &lt;- poids / (tailles / 100) ^ 2 # Valeurs extrêmes de l&#39;IMC min(imc) max(imc) 2.2.5 Installer et charger des extensions (packages) R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). Pour installer une extension, si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install. On peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande : install.packages(&quot;questionr&quot;) Installer une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC. Cela suppose que vous disposez d’une connexion internet. Cependant, il est possible d’installer des packages en local sans connexion internet sous réserve d’être en possession des packages en fichiers zippés. Une fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante : library(questionr) Ainsi, bien souvent, on regroupe en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme : library(readxl) library(ggplot2) library(questionr) Si vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante. 2.2.6 Exercices 2.2.6.1 Sujet Exercice 1 Construire le vecteur x suivant : ## [1] 120 134 256 12 Utiliser ce vecteur x pour générer les deux vecteurs suivants : ## [1] 220 234 356 112 ## [1] 240 268 512 24 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) Recommencer avec les revenus suivants, parmi lesquels l’un des enquêtés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) Exercice 4 Les deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes sur la ville de Lyon, pour chaque mois de l’année, entre 1981 et 2010 : temperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4) precipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2) Calculer la température moyenne sur l’année. Calculer la quantité totale de précipitations sur l’année. À quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire. cumsum(precipitations) ## [1] 47.2 91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 ## [12] 831.9 Même question pour : diff(temperature) ## [1] 1.4 3.6 3.0 4.4 3.6 2.8 -0.6 -4.0 -4.2 -5.8 -3.2 Exercice 5 On a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs : maths &lt;- c(12, 16, 8, 18, 6, 10) anglais &lt;- c(14, 9, 13, 15, 17, 11) sport &lt;- c(18, 11, 14, 10, 8, 12) Calculer la moyenne des élèves de la classe en anglais. Calculer la moyenne générale de chaque élève. Essayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) : pmin(maths, anglais, sport) ## [1] 12 9 8 10 6 10 pmax(maths, anglais, sport) ## [1] 18 16 14 18 17 12 2.2.6.2 Correction Exercice 1 Construire le vecteur x suivant : ## [1] 120 134 256 12 x &lt;- c(120, 134, 256, 12) Utiliser ce vecteur x pour générer les deux vecteurs suivants : ## [1] 220 234 356 112 ## [1] 240 268 512 24 x + 100 x * 2 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage. revenu_total &lt;- conjoint1 + conjoint2 revenu_total / nb_personnes Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) range(conjoint1) Recommencer avec les revenus suivants, parmi lesquels l’un des enquêtés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) range(conjoint1, na.rm = TRUE) Exercice 4 Les deux vecteurs suivants représentent les précipitations (en mm) et la température (en °C) moyennes sur la ville de Lyon, pour chaque mois de l’année, entre 1981 et 2010 : temperature &lt;- c(3.4, 4.8, 8.4, 11.4, 15.8, 19.4, 22.2, 21.6, 17.6, 13.4, 7.6, 4.4) precipitations &lt;- c(47.2, 44.1, 50.4, 74.9, 90.8, 75.6, 63.7, 62, 87.5, 98.6, 81.9, 55.2) Calculer la température moyenne sur l’année. Calculer la quantité totale de précipitations sur l’année. mean(temperature) sum(precipitations) À quoi correspond et comment peut-on interpréter le résultat de la fonction suivante ? Vous pouvez vous aider de la page d’aide de la fonction si nécessaire. cumsum(precipitations) ## [1] 47.2 91.3 141.7 216.6 307.4 383.0 446.7 508.7 596.2 694.8 776.7 ## [12] 831.9 Même question pour : diff(temperature) ## [1] 1.4 3.6 3.0 4.4 3.6 2.8 -0.6 -4.0 -4.2 -5.8 -3.2 cumsum(precipitations) correspond à la somme cumulée des précipitations sur l’année. Par exemple, la 6e valeur du vecteur résultat correspond au total de précipitations de janvier à juin. diff(temperature) correspond à la différence de température d’un mois sur l’autre. Par exemple, la 2e valeur de ce vecteur correspond à l’écart de température entre le mois de février et le mois de janvier. Exercice 5 On a relevé les notes en maths, anglais et sport d’une classe de 6 élèves et on a stocké ces données dans trois vecteurs : maths &lt;- c(12, 16, 8, 18, 6, 10) anglais &lt;- c(14, 9, 13, 15, 17, 11) sport &lt;- c(18, 11, 14, 10, 8, 12) Calculer la moyenne des élèves de la classe en anglais. Calculer la moyenne générale de chaque élève. mean(anglais) (maths + anglais + sport) / 3 Essayez de comprendre le résultat des deux fonctions suivantes (vous pouvez vous aider de la page d’aide de ces fonctions) : pmin(maths, anglais, sport) ## [1] 12 9 8 10 6 10 pmax(maths, anglais, sport) ## [1] 18 16 14 18 17 12 pmin et pmax renvoient les minimum et maximum “parallèles” des trois vecteurs passés en argument. Ainsi, pmin renvoie pour chaque élève la note minimale dans les trois matières, et pmax la note maximale. On peut ignorer pour le moment la présence du [1] en début de ligne.↩ Et permet de constater que pour R, un nombre est un vecteur à un seul élément.↩ c est l’abréviation de combine, son nom est très court car on l’utilise très souvent↩ "],
["diffuser-et-publier-des-rapports-automatisés-avec-rmarkdown.html", "3 Diffuser et publier des rapports automatisés avec rmarkdown 3.1 Créer un nouveau document 3.2 Éléments d’un document R Markdown 3.3 Personnaliser le document généré 3.4 Options des blocs de code R 3.5 Rendu des tableaux", " 3 Diffuser et publier des rapports automatisés avec rmarkdown Ce chapitre est extrait du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) L’extension rmarkdown permet de générer des documents de manière dynamique en mélangeant texte mis en forme et résultats produits par du code R. Les documents générés peuvent être au format HTML, PDF, Word. C’est donc un outil très pratique pour l’exportation, la communication et la diffusion de résultats d’analyse. Le présent document a lui-même été généré à partir de fichiers R Markdown. rmarkdown ne fait pas partie du tidyverse, mais elle est installée et chargée par défaut par RStudio4. Voici un exemple de document R Markdown minimal : Ce document peut être “compilé” sous différents formats. Lors de cette étape, le texte est mis en forme, les blocs de code sont exécutés, leur résultat ajouté au document, et le tout est transformé dans un des différents formats possibles. Voici le rendu du document précédent au format HTML : Le rendu du même document au format PDF : Et le rendu au format docx : Les avantages de ce système sont nombreux : le code et ses résultats ne sont pas séparés des commentaires qui leur sont associés le document final est reproductible le document peut être très facilement régénéré et mis à jour, par exemple si les données source ont été modifiées. 3.1 Créer un nouveau document Un document R Markdown est un simple fichier texte enregistré avec l’extension .Rmd. Sous RStudio, on peut créer un nouveau document en allant dans le menu File puis en choisissant New file puis R Markdown…. La boîte de dialogue suivante s’affiche : On peut indiquer le titre, l’auteur du document ainsi que le format de sortie par défaut (il est possible de modifier facilement ces éléments par la suite). Un fichier comportant un contenu d’exemple s’affiche alors. Vous pouvez l’enregistrer où vous le souhaitez avec une extension .Rmd. 3.2 Éléments d’un document R Markdown 3.2.1 En-tête (préambule) La première partie du document est son en-tête. Il se situe en tout début de document, et est délimité par trois tirets (---) avant et après : --- title: &quot;Titre&quot; author: &quot;Prénom Nom&quot; date: &quot;10 avril 2017&quot; output: html_document --- Cet en-tête contient les métadonnées du document, comme son titre, son auteur, sa date, plus tout un tas d’options possibles qui vont permettre de configurer ou personnaliser l’ensemble du document et son rendu. Ici, par exemple, la ligne output: html_document indique que le document généré doit être au format HTML. 3.2.2 Texte du document Le corps du document est constitué de texte qui suit la syntaxe Markdown. Un fichier Markdown est un fichier texte contenant un balisage léger qui permet de définir des niveaux de titres ou de mettre en forme le texte. Par exemple, le texte suivant : Ceci est du texte avec *de l&#39;italique* et **du gras**. On peut définir des listes à puces : - premier élément - deuxième élément Génèrera le texte mis en forme suivant : Ceci est du texte avec de l’italique et du gras. On peut définir des listes à puces : premier élément deuxième élément On voit que des mots placés entre des astérisques sont mis en italique, des lignes qui commencent par un tiret sont transformés en liste à puce, etc. On peut définir des titres de différents niveaux en faisant débuter une ligne par un ou plusieurs # : # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 Quand des titres ont été définis, si vous cliquez sur l’icône Show document outline totalement à droite de la barre d’outils associée au fichier R Markdown, une table des matières générée automatiquement à partir des titres s’affiche et vous permet de naviguer facilement dans le document : La syntaxe Markdown permet d’autres mises en forme, comme la possibilité d’insérer des liens ou des images. Par exemple, le code suivant : [Exemple de lien](https://example.com) Donnera le lien suivant : Exemple de lien Dans RStudio, le menu Help puis Markdown quick reference donne un aperçu plus complet de la syntaxe. 3.2.3 Blocs de code R En plus du texte libre au format Markdown, un document R Markdown contient, comme son nom l’indique, du code R. Celui-ci est inclus dans des blocs (chunks) délimités par la syntaxe suivante. Comme cette suite de caractères n’est pas très simple à saisir, vous pouvez utiliser le menu Insert de RStudio et choisir R5, ou utiliser le raccourci clavier Ctrl+Alt+i. Dans RStudio les blocs de code R sont en général affichés avec une couleur de fond légèrement différente pour les distinguer du reste du document. Quand votre curseur se trouve dans un bloc, vous pouvez saisir le code R que vous souhaitez, l’exécuter, utiliser l’autocomplétion, exactement comme si vous vous trouviez dans un script R. Vous pouvez également exécuter l’ensemble du code contenu dans un bloc à l’aide du raccourci clavier Ctrl+Maj+Entrée. Dans RStudio, par défaut, les résultats d’un bloc de code (texte, tableau ou graphique) s’affichent directement dans la fenêtre d’édition du document, permettant de les visualiser facilement et de les conserver le temps de la session 6. Lorsque le document est “compilé” au format HTML, PDF ou docx, chaque bloc est exécuté tour à tour, et le résultat inclus dans le document final, qu’il s’agisse de texte, d’un tableau ou d’un graphique. Les blocs sont liés entre eux, dans le sens où les données importées ou calculées dans un bloc sont accessibles aux blocs suivants. On peut donc aussi voir un document R Markdown comme un script R dans lequel on aurait intercalé du texte libre au format Markdown. À noter qu’avant chaque compilation, une nouvelle session R est lancée, ne contenant aucun objet. Les premiers blocs de code d’un document sont donc souvent utilisés pour importer des données, exécuter des recodages, etc. 3.2.4 Compiler un document (Knit) On peut à tout moment compiler, ou plutôt “tricoter” (Knit), un document R Markdown pour obtenir et visualiser le document généré. Pour cela, il suffit de cliquer sur le bouton Knit et de choisir le format de sortie voulu : Vous pouvez aussi utiliser le raccourci Ctrl+Maj+K pour compiler le document dans le dernier format utilisé. Pour la génération du format PDF, vous devez avoir une installation fonctionnelle de LaTeX sur votre système. Si ça n’est pas le cas, l’extension tinytex de Yihui Xie vise à faciliter l’installation d’une distribution LaTeX minimale quel que soit le système d’exploitation de votre machine. Pour l’utiliser il vous faut d’abord installer l’extension avec install.packages('tinytex'), puis lancer la commande suivante dans la console (prévoir un téléchargement d’environ 200Mo) : tinytex::install_tinytex() Plus d’informations sur le site de tinytex. Un onglet R Markdown s’ouvre dans la même zone que l’onglet Console et indique la progression de la compilation, ainsi que les messages d’erreur éventuels. Si tout se passe bien, Le document devrait s’afficher soit dans une fenêtre Viewer de RStudio (pour la sortie HTML), soit dans le logiciel par défaut de votre ordinateur. 3.3 Personnaliser le document généré La personnalisation du document généré se fait en modifiant des options dans le préambule du document. RStudio propose néanmoins une petite interface graphique permettant de changer ces options plus facilement. Pour cela, cliquez sur l’icône en forme d’engrenage à droite du bouton Knit et choisissez Output Options… Une boîte de dialogue s’affiche vous permettant de sélectionner le format de sortie souhaité et, selon le format, différentes options : Pour le format HTML par exemple, l’onglet General vous permet de spécifier si vous voulez une table des matières, sa profondeur, les thèmes à appliquer pour le document et la coloration syntaxique des blocs R, etc. L’onglet Figures vous permet de changer les dimensions par défaut des graphiques générés. Une option très intéressante pour les fichiers HTML, accessible via l’onglet Advanced, est l’entrée Create standalone HTML document. Si elle est cochée (ce qui est le cas par défaut), le document HTML généré contiendra en un seul fichier le code HTML mais aussi les images et toutes les autres ressources nécessaires à son affichage. Ceci permet de générer des fichiers (parfois assez volumineux) que vous pouvez transférer très facilement à quelqu’un par mail ou en le mettant en ligne quelque part. Si la case n’est pas cochée, les images et autres ressources sont placées dans un dossier à part. Lorsque vous changez des options, RStudio va en fait modifier le préambule de votre document. Ainsi, si vous choisissez d’afficher une table des matières et de modifier le thème de coloration syntaxique, votre en-tête va devenir quelque chose comme : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes --- Vous pouvez modifier les options directement en éditant le préambule. À noter qu’il est possible de spécifier des options différentes selon les formats, par exemple : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes pdf_document: fig_caption: yes highlight: kate --- La liste complète des options possibles est présente sur le site de la documentation officielle (très complet et bien fait) et sur l’antisèche et le guide de référence, accessibles depuis RStudio via le menu Help puis Cheatsheets. 3.4 Options des blocs de code R Il est également possible de passer des options à chaque bloc de code R pour modifier son comportement. On rappelle qu’on bloc de code se présente de la manière suivante : ```{r} x &lt;- c(1,2,3,4,5) ``` Les options d’un bloc de code sont à placer à l’intérieur des accolades {r}. 3.4.1 Nom du bloc La première possibilité est de donner un nom au bloc. Celui-ci est indiqué directement après le r : {r nom_du_bloc} Il n’est pas obligatoire de nommer un bloc, mais cela peut être utile en cas d’erreur à la compilation, pour identifier le bloc ayant causé le problème. Attention, on ne peut pas avoir deux blocs avec le même nom. 3.4.2 Options En plus d’un nom, on peut passer à un bloc une série d’options sous la forme option = valeur. Voici un exemple de bloc avec un nom et des options : ```{r mon_bloc, echo = FALSE, warning = TRUE} x &lt;- c(1,2,3,4,5) ``` Et un exemple de bloc non nommé avec des options : ```{r echo = FALSE, warning = FALSE} x &lt;- c(1,2,3,4,5) ``` Une des options la plus utile est l’option echo. Par défaut echo vaut TRUE, et le bloc de code R est inséré dans le document généré, de cette manière : x &lt;- 1:5 print(x) ## [1] 1 2 3 4 5 Mais si on positionne l’option echo=FALSE, alors le code R n’est plus inséré dans le document, et seul le résultat est visible : ## [1] 1 2 3 4 5 Voici une liste de quelques-unes des options disponibles : Il existe de nombreuses autres options décrites notamment dans guide de référence R Markdown (PDF en anglais). 3.4.3 Modifier les options Il est possible de modifier les options manuellement en éditant l’en-tête du bloc de code, mais on peut aussi utiliser une petite interface graphique proposée par RStudio. Pour cela, il suffit de cliquer sur l’icône d’engrenage située à droite sur la ligne de l’en-tête de chaque bloc : Vous pouvez ensuite modifier les options les plus courantes, et cliquer sur Apply pour les appliquer. 3.4.4 Options globales On peut vouloir appliquer une option à l’ensemble des blocs d’un document. Par exemple, on peut souhaiter par défaut ne pas afficher le code R de chaque bloc dans le document final. On peut positionner une option globalement en utilisant la fonction knitr::opts_chunk$set(). Par exemple, insérer knitr::opts_chunk$set(echo = FALSE) dans un bloc de code positionnera l’option echo = FALSE par défaut pour tous les blocs suivants. En général, on place toutes ces modifications globales dans un bloc spécial nommé setup et qui est le premier bloc du document : ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` Par défaut RStudio exécute systématiquement le contenu du bloc setup avant d’exécuter celui d’un autre bloc. Contrairement aux autres blocs de code, quand on utilise dans RStudio le menu des paramètres du bloc setup pour modifier ses options, celles-ci modifient non pas les options de ce bloc mais les options globales, en mettant à jour l’appel de la fonction knitr::opts_chunk$set(). 3.4.5 Mise en cache des résultats Compiler un document R Markdown peut être long, car il faut à chaque fois exécuter l’ensemble des blocs de code R qui le constituent. Pour accélérer cette opération, R Markdown utilise un système de mise en cache : les résultats de chaque bloc sont enregistrés dans un fichier et à la prochaine compilation, si le code et les options du bloc n’ont pas été modifiés, c’est le contenu du fichier de cache qui est utilisé, ce qui évite d’exécuter le code R. On peut activer ou désactiver la mise en cache des résultats pour chaque bloc de code avec l’option cache = TRUE ou cache = FALSE, et on peut aussi désactiver totalement la mise en cache pour le document en ajoutant knitr::opts_chunk$set(cache = FALSE) dans le premier bloc setup. Ce système de cache peut poser problème par exemple si les données source changent : dans ce cas les résultats de certains blocs peuvent ne pas être mis à jour s’ils sont présents en cache. Dans ce cas, on peut vider le cache du document, ce qui forcera un recalcul de tous les blocs de code à la prochaine compilation. Pour cela, vous pouvez ouvrir le menu Knit et choisir Clear Knitr Cache… : 3.5 Rendu des tableaux 3.5.1 Tableaux croisés Par défaut, les tableaux issus de la fonction table sont affichés comme ils apparaissent dans la console de R, en texte brut : library(questionr) data(hdv2003) tab &lt;- lprop(table(hdv2003$qualif, hdv2003$sexe)) tab ## ## Homme Femme Total ## Ouvrier specialise 47.3 52.7 100.0 ## Ouvrier qualifie 78.4 21.6 100.0 ## Technicien 76.7 23.3 100.0 ## Profession intermediaire 55.0 45.0 100.0 ## Cadre 55.8 44.2 100.0 ## Employe 16.2 83.8 100.0 ## Autre 36.2 63.8 100.0 ## Ensemble 44.8 55.2 100.0 On peut améliorer leur présentation en utilisant la fonction kable de l’extension knitr. Celle-ci fournit un formatage adapté en fonction du format de sortie. On aura donc des tableaux “propres” que ce soit en HTML, PDF ou aux formats traitements de texte : library(knitr) kable(tab) Homme Femme Total Ouvrier specialise 47.29064 52.70936 100 Ouvrier qualifie 78.42466 21.57534 100 Technicien 76.74419 23.25581 100 Profession intermediaire 55.00000 45.00000 100 Cadre 55.76923 44.23077 100 Employe 16.16162 83.83838 100 Autre 36.20690 63.79310 100 Ensemble 44.82759 55.17241 100 Différents arguments permettent de modifier la sortie de kable. digits, par exemple, permet de spécifier le nombre de chiffres significatifs à afficher dans les colonnes de nombres : kable(tab, digits = 1) Homme Femme Total Ouvrier specialise 47.3 52.7 100 Ouvrier qualifie 78.4 21.6 100 Technicien 76.7 23.3 100 Profession intermediaire 55.0 45.0 100 Cadre 55.8 44.2 100 Employe 16.2 83.8 100 Autre 36.2 63.8 100 Ensemble 44.8 55.2 100 Il est possible d’inclure dans un document R Markdown des blocs de code d’autres langages↩ Ce comportement peut être modifié en cliquant sur l’icône d’engrenage de la barre d’outils et en choisissant Chunk Output in Console↩ "],
["premier-travail-avec-des-données.html", "4 Premier travail avec des données 4.1 Jeu de données d’exemple 4.2 Tableau de données (data frame) 4.3 Analyse univariée 4.4 Exercices", " 4 Premier travail avec des données Ce document est extrait du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) 4.1 Jeu de données d’exemple Dans cette partie nous allons (enfin) travailler sur des “vraies” données, et utiliser un jeu de données présent dans l’extension questionr. Nous devons donc avant toute chose installer cette extension. Pour installer ce package, deux possibilités : Dans l’onglet Packages de la zone de l’écran en bas à droite, cliquez sur le bouton Install. Dans le dialogue qui s’ouvre, entrez “questionr” dans le champ Packages puis cliquez sur Install. Saisissez directement la commande suivante dans la console : install.packages(\"questionr\") Dans les deux cas, tout un tas de messages devraient s’afficher dans la console. Attendez que l’invite de commandes &gt; apparaisse à nouveau. Le jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) : library(questionr) L’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension. Nous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data : data(hdv2003) Cette commande ne renvoie aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003 : Cet objet est d’un type nouveau : il s’agit d’un tableau de données. 4.2 Tableau de données (data frame) Un data frame (ou tableau de données, ou table) est un type d’objet R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel. Si on se contente d’exécuter le nom de notre tableau de données : hdv2003 R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile. Une autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment : Ou d’utiliser la fonction View : View(x = hdv2003) Dans les deux cas votre tableau devrait s’afficher dans RStudio avec une interface de type tableur : Il est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille7. Sous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine. Un data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire : d &lt;- hdv2003 ce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite. Pour résumer, comme nous avons désormais décidé de saisir nos commandes dans un script et non plus directement dans la console, les premières lignes de notre fichier de travail sur les données de l’enquête Histoire de vie pourraient donc ressembler à ceci : ## Chargement des extensions nécessaires library(questionr) ## Jeu de données hdv2003 data(hdv2003) d &lt;- hdv2003 4.2.1 Structure du tableau Un tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau : nrow(x = d) ## [1] 2000 ncol(x = d) ## [1] 20 La fonction dim renvoie ses dimensions, donc les deux nombres précédents : dim(x = d) ## [1] 2000 20 La fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables : names(x = d) ## [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; ## [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; ## [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; ## [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; ## [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; On peut aussi utiliser la fonction colnames : colnames(x = d) ## [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; ## [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; ## [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; ## [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; ## [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; Enfin, la fonction str renvoie un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type 8 et affiche les premières valeurs : str(object = d) ## &#39;data.frame&#39;: 2000 obs. of 20 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ age : int 28 23 59 34 71 35 60 47 20 28 ... ## $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 2 2 1 1 2 2 2 1 2 1 ... ## $ nivetud : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8 3 6 3 6 NA 7 ... ## $ poids : num 2634 9738 3994 5732 4329 ... ## $ occup : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3 1 1 4 1 6 1 3 1 ... ## $ qualif : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 6 NA 3 3 6 6 2 2 NA 7 ... ## $ freres.soeurs: int 8 2 2 1 0 5 1 5 4 2 ... ## $ clso : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1 2 2 1 2 1 2 1 2 ... ## $ relig : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4 4 3 1 4 3 4 3 2 ... ## $ trav.imp : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA 2 3 NA 1 NA 4 NA 3 ... ## $ trav.satisf : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA 3 1 NA 3 NA 2 NA 1 ... ## $ hard.rock : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ lecture.bd : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 2 2 1 1 ... ## $ cuisine : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 2 1 1 2 2 1 1 ... ## $ bricol : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 2 1 1 1 2 1 1 ... ## $ cinema : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 2 1 2 1 1 2 2 ... ## $ sport : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 2 1 2 1 1 1 2 ... ## $ heures.tv : num 0 1 0 2 3 2 2.9 1 2 2 ... Sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment : 4.2.2 Accéder aux variables d’un tableau Une opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On utilise pour cela l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape : d$sexe ## [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme ## [12] Homme Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme ## [23] Femme Femme Femme Homme Femme Homme Homme Homme Homme Homme Homme ## [34] Homme Femme Femme Homme Femme Femme Homme Femme Homme Homme Femme ## [45] Femme Homme Femme Femme Femme Femme Homme Femme Homme Femme Homme ## [56] Femme Femme Femme Homme Femme Femme Homme Homme Homme Homme Femme ## [67] Homme Homme Femme Femme Homme Homme Femme Femme Femme Femme Homme ## [78] Femme Femme Femme Femme Femme Femme Homme Homme Femme Homme Homme ## [89] Homme Homme Homme Femme Homme Femme Femme Femme Homme Homme Femme ## [100] Femme Femme Homme Femme Homme Homme Femme Femme Femme Femme Homme ## [111] Homme Homme Homme Homme Femme Homme Homme Femme Homme Homme Femme ## [122] Femme Femme Homme Femme Femme Homme Femme Femme Homme Femme Homme ## [133] Femme Femme Femme Homme Homme Homme Homme Homme Homme Homme Homme ## [144] Femme Homme Homme Homme Femme Femme Femme Homme Femme Femme Femme ## [155] Femme Homme Femme Homme Homme Homme Femme Homme Femme Homme Femme ## [166] Homme Homme Femme Femme Femme Homme Femme Homme Femme Femme Femme ## [177] Homme Homme Homme Femme Homme Femme Femme Homme Homme Femme Femme ## [188] Femme Femme Femme Homme Homme Femme Homme Homme Femme Homme Femme ## [199] Homme Femme ## [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] ## Levels: Homme Femme R va nous afficher l’ensemble des valeurs de notre variable sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment. Pour le moment, on ne fait pas attention à Levels: Homme Femme La fonction table$colonne renvoie donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères. Si on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail : head(x = d$age) ## [1] 28 23 59 34 71 35 tail(x = d$age, 10) ## [1] 52 42 50 41 46 45 46 24 24 66 Le deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher. 4.2.3 Créer une nouvelle variable On peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur. Par exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé : head(x = d$heures.tv, n = 10) ## [1] 0.0 1.0 0.0 2.0 3.0 2.0 2.9 1.0 2.0 2.0 On peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée mais en minutes. On va donc créer une nouvelle variable minutes.tv de la manière suivante : d$minutes.tv &lt;- d$heures.tv * 60 On peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau : head(x = d$minutes.tv) ## [1] 0 60 0 120 180 120 On peut également supprimer une colonne d’un data frame en utilisant &lt;- NULL #création d&#39;une colonne temporaire d$temp &lt;- NA #vérification de la création de la colonne d$temp ## [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [24] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [47] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [70] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [93] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [116] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [139] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [162] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [185] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] #nombre de colonne avant la suppression ncol(x = d) ## [1] 22 #suppression de la colonne d$temp &lt;- NULL #nombre de colonne après la suppression ncol(x = d) ## [1] 21 4.3 Analyse univariée On a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $. Si on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs : l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités : le sexe, la profession, le dernier diplôme obtenu, etc.). 4.3.1 Analyser une variable quantitative Une variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv). 4.3.1.1 Indicateurs de centralité Caractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent. Pour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range : min(x = d$age) ## [1] 18 max(x = d$age) ## [1] 97 range(x = d$age) ## [1] 18 97 On peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean : mean(x = d$age) ## [1] 48.157 Il existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median : median(x = d$age) ## [1] 48 Une différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2013, le salaire net moyen des salariés à temps plein en France était de 2202 euros, tandis que le salaire net médian n’était que de 1772 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut. 4.3.1.2 Indicateurs de dispersion Les indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées. L’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations : max(d$age) - min(d$age) ## [1] 79 Les indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abréviation de standard deviation) : var(x = d$age) ## [1] 287.0249 sd(x = d$age) ## [1] 16.94181 Plus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées. Une autre manière de mesurer la dispersion est de calculer les quartiles : le premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au-dessus le deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au-dessus (c’est donc la médiane) le troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au-dessus On peut les calculer avec la fonction quantile : ## Premier quartile quantile(x = d$age, prob = 0.25) ## 25% ## 35 ## Troisième quartile quantile(x = d$age, prob = 0.75) ## 75% ## 60 L’argument quantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc. Par défaut, la fonction quantile affiche le min, max et les quartiles de la série : quantile(x = d$age) ## 0% 25% 50% 75% 100% ## 18 35 48 60 97 Attention ! L’ensemble des fonctions statistiques sont sensibles à la présence de valeurs manquantes NA. On utilisera l’argument na.rm = TRUE pour éviter les erreurs. Notons enfin que la fonction summary permet d’obtenir d’un coup plusieurs indicateurs classiques : summary(object = d$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 18.00 35.00 48.00 48.16 60.00 97.00 4.3.1.3 Représentation graphique L’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique. La représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist : hist(x = d$age) Cette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio. On peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite. hist(x = d$age, breaks = 10) hist(x = d$age, breaks = 70) Le choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances. Les arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col9, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. : hist(x = d$age, col = &quot;skyblue&quot;, main = &quot;Répartition des âges des enquêtés&quot;, xlab = &quot;Âge&quot;, ylab = &quot;Effectif&quot;) La fonction hist fait partie des fonctions graphique de base de R. Elle est souvent associée au graphique boîtes à moustaches (boxplot) qui permet de résumer la distribution d’une variable quantitative à travers les quartiles notamment. boxplot(x = d$age, main = &quot;Distribution de l&#39;âge&quot;) 4.3.2 Analyser une variable qualitative Une variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)… À noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs. 4.3.2.1 Tri à plat L’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table : table(x = d$sexe) ## x ## Homme Femme ## 899 1101 Ce tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes. table(x = d$qualif) ## x ## Ouvrier specialise Ouvrier qualifie Technicien ## 203 292 86 ## Profession intermediaire Cadre Employe ## 160 260 594 ## Autre ## 58 Un tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tri à plat selon la valeur de l’effectif. On peut donc faire : tab &lt;- table(x = d$qualif) sort(tab) ## x ## Autre Technicien Profession intermediaire ## 58 86 160 ## Ouvrier specialise Cadre Ouvrier qualifie ## 203 260 292 ## Employe ## 594 Attention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = \"always\", soit : table(d$qualif, useNA = \"always\"). À noter qu’on peut aussi appliquer summary à une variable qualitative. Le résultat est également le tri à plat de la variable, avec en plus le nombre de valeurs manquantes éventuelles : summary(object = d$qualif) ## Ouvrier specialise Ouvrier qualifie Technicien ## 203 292 86 ## Profession intermediaire Cadre Employe ## 160 260 594 ## Autre NA&#39;s ## 58 347 Par défaut ces tris à plat sont en effectifs et ne sont donc pas toujours très lisibles, notamment quand on a des effectifs importants. On leur rajoute donc en général la répartition en pourcentages. Pour cela, nous allons utiliser la fonction freq de l’extension questionr, qui devra donc avoir précédemment été chargée avec library(questionr) : ## À rajouter en haut de script et à exécuter library(questionr) On peut alors utiliser la fonction : freq(x = d$qualif) ## n % val% ## Ouvrier specialise 203 10.2 12.3 ## Ouvrier qualifie 292 14.6 17.7 ## Technicien 86 4.3 5.2 ## Profession intermediaire 160 8.0 9.7 ## Cadre 260 13.0 15.7 ## Employe 594 29.7 35.9 ## Autre 58 2.9 3.5 ## NA 347 17.3 NA La colonne n représente les effectifs de chaque catégorie, la colonne % le pourcentage, et la colonne val% le pourcentage calculé sur les valeurs valides, donc en excluant les NA. Une ligne a également été rajoutée pour indiquer le nombre et la proportion de NA. freq accepte un certain nombre d’arguments pour personnaliser son affichage. Par exemple : valid indique si on souhaite ou non afficher les pourcentages sur les valeurs valides cum indique si on souhaite ou non afficher les pourcentages cumulés total permet d’ajouter une ligne avec les effectifs totaux sort permet de trier le tableau par fréquence croissante (sort=\"inc\") ou décroissante (sort=\"dec\"). freq(x = d$qualif, valid = FALSE, total = TRUE, sort = &quot;dec&quot;) ## n % ## Employe 594 29.7 ## Ouvrier qualifie 292 14.6 ## Cadre 260 13.0 ## Ouvrier specialise 203 10.2 ## Profession intermediaire 160 8.0 ## Technicien 86 4.3 ## Autre 58 2.9 ## NA 347 17.3 ## Total 2000 100.0 4.3.2.2 Représentations graphiques On peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes : tab &lt;- table( x = d$qualif ) barplot(height = tab, main = &#39;Répartition par qualification&#39;, las= 2, cex.names = 0.4) L’argument las permet de pivoter les étiquettes et cex.names la taille de la police. On peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique : La fonction pie permet de construire un diagramme circulaire. Il fonctionne de la même manière que la fonction barplot. tab &lt;- table(x = d$sexe) pie(x = tab) 4.4 Exercices 4.4.1 Sujet Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr charger le jeu de données nommé hdv2003 copier le jeu de données dans un nouvel objet nommé df afficher les dimensions et la liste des variables de df Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ? Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres. Utilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato. 4.4.2 Correction Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr library(questionr) charger le jeu de données nommé hdv2003 data(hdv2003) copier le jeu de données dans un nouvel objet nommé df df &lt;- hdv2003 afficher les dimensions et la liste des variables de df dim(x = df) names(x = df) Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. summary(object = df$heures.tv) sd(x = df$heures.tv) hist(x = df$heures.tv, breaks = 10) Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. table(x = df$trav.imp) Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Y’a-t-il des valeurs manquantes ? freq(x = df$trav.imp) Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres. tab &lt;- sort(x = table(x = df$trav.imp)) barplot(height = tab) Utilisez l’argument col de la fonction barplot pour modifier la couleur du graphique en tomato. barplot(height = tab, col = &quot;tomato&quot;) Tapez colors() dans la console pour afficher l’ensemble des noms de couleurs disponibles dans R. La seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩ Les différents types de variables seront décrits plus en détail dans un autre TD sur les recodages.↩ Les différentes manières de spécifier des couleurs seront abordées plus tard.↩ "],
["importer-des-données-externes.html", "5 Importer des données externes 5.1 Modifier le répertoire actif 5.2 Import de fichiers textes 5.3 Interface interactive d’import de fichiers 5.4 Import depuis un fichier Excel 5.5 Export de données 5.6 Exercices", " 5 Importer des données externes Ce document est extrait du cours de Julien Barnier “Introduction à R et au tidyverse” (https://juba.github.io/tidyverse) R n’est pas prévu pour la saisie de données, mais il bénéficie de nombreuses fonctions et packages permettant l’import de données depuis un grand nombre de formats. Seuls les plus courants seront abordés ici. 5.1 Modifier le répertoire actif La fonction getwd permet d’afficher le répertoire actif. getwd() ## [1] &quot;C:/Users/anthony.sardellitti/Programmation_Statistique_R&quot; Renseigner un répertoire actif permet notamment d’éviter de saisir le chemin complet d’un fichier de données tel que C:/Document/dataset/mon_fichier.txt Pour modifier le répertoire courant, on utilise la fonction setwdtel que setwd(“C:/Users/anthony/Formations”) On peut également faire la même opération en cliquant sur Session, puis Set Working Directory et Choose Directory. 5.2 Import de fichiers textes Si votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read.csv en lui passant en argument le nom du fichier : d &lt;- read.csv(file = &quot;./dataset/Titanic.csv&quot;) Il existe plusieurs variantes à la fonction read.csv, la différence réside dans les arguments par défaut. Dans la même famille de fonction, chaque fonction dispose de plusieurs arguments, parmi lesquels : file indique le chemin d’accès au fichier header permet de spécifier si la première ligne correspond aux noms des colonnes sep indique par quel caractère sont séparées les colonnes (“\\t” pour les tabulations) dec indique par quel caractère joue le rôle de la décimale (. ou ,) row.names permet de spécifier quel numéro de colonne peut être considéré comme le numéro d’index des lignes na.strings est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(\"\", \"NA\") par défaut `encoding’ permet de gérer l’encodage Il peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut alors spécifier manuellement l’encodage avec cet argument d &lt;- read.csv(file = &quot;./dataset/Titanic.csv&quot;, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, row.names = 1, na.strings = c(NA,&quot;NULL&quot;,&quot;None&quot;), encoding = &quot;Latin-1&quot;) 5.3 Interface interactive d’import de fichiers RStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour y accéder, dans l’onglet Environment, cliquez sur le bouton Import Dataset : L’extension readr, qui fait partie du tidyverse, permet l’importation de fichiers txt, csv, excel mais le nom des fonctions et des arguments sont différents. Sélectionnez From Text (readr)…. Une nouvelle fenêtre s’affiche : Il vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct : Vous pouvez modifier les options d’importation, changer le type des colonnes, etc. et l’aperçu se met à jour. De même, le code correspondant à l’importation du fichier avec les options sélectionnées est affiché dans la partie Code Preview. Important : une fois que l’import semble correct, ne cliquez pas sur le bouton Import. À la place, sélectionnez le code généré et copiez-le (ou cliquez sur l’icône en forme de presse papier) et choisissez Cancel. Ensuite, collez le code dans votre script et exécutez-le (vous pouvez supprimer la ligne commençant par View). Cette manière de faire permet “d’automatiser” l’importation des données, puisqu’à la prochaine ouverture du script vous aurez juste à exécuter le code en question, sans repasser par l’interface d’import. 5.4 Import depuis un fichier Excel L’extension readxl, qui fait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx. Elle ne fait pas partie du “coeur” du tidyverse, il faut donc la charger explicitement avec : library(readxl) On peut alors utiliser la fonction read_excel en lui spécifiant le nom du fichier : d &lt;- read_excel(path = &quot;./dataset/Titanic.xlsx&quot;) Il est possible de spécifier la feuille et la plage de cellules que l’on souhaite importer avec les arguments sheet et range : d &lt;- read_excel(path = &quot;./dataset/Titanic.xlsx&quot;, sheet = &quot;Feuil1&quot;, range = &quot;A1:G1314&quot;) Comme pour l’import de fichiers texte, une interface interactive d’import de fichiers Excel est disponible dans RStudio dans l’onglet Environment. Pour y accéder, cliquez sur Import Dataset puis From Excel…. Spécifiez le chemin ou l’URL du fichier dans le premier champ, vérifiez l’import dans la partie Data Preview, modifiez si besoin les options d’importation, copiez le code d’importation généré dans la partie Code Preview et collez le dans votre script. Pour plus d’informations, voir le site de l’extension readxl. 5.5 Export de données 5.5.1 Export de tableaux de données On peut avoir besoin d’exporter un tableau de données dans R vers un fichier dans différents formats. La plupart des fonctions d’import disposent d’un équivalent permettant l’export de données. On citera notamment : write.csv, permet d’enregistrer un data frame dans un fichier au format texte délimité Il n’existe par contre pas de fonctions permettant d’enregistrer directement au format xls ou xlsx. On peut dans ce cas passer par un fichier CSV. Ces fonctions sont utiles si on souhaite diffuser des données à quelqu’un d’autre, ou entre deux logiciels. Si vous travaillez sur des données de grandes dimensions, les formats texte peuvent être lents à exporter et importer. Dans ce cas, l’extension feather peut être utile : elle permet d’enregistrer un data frame au format feather, qui n’est pas le plus compact mais qui est extrêmement rapide à lire et écrire 10. Les fonctions read_feather et write_feather permettent d’importer et exporter des tableaux de données dans ce format. 5.5.2 Sauvegarder des objets Une autre manière de sauvegarder des données est de les enregistrer au format RData. Ce format propre à R est compact, rapide, et permet d’enregistrer plusieurs objets R, quel que soit leur type, dans un même fichier. Pour enregistrer des objets, il suffit d’utiliser la fonction save et de lui fournir la liste des objets à sauvegarder et le nom du fichier : save(... = d, file = &quot;fichier.RData&quot;) Pour charger des objets préalablement enregistrés, utiliser load : load(file = &quot;fichier.RData&quot;) Les objets ddevrait alors apparaître dans votre environnement. Attention, quand on utilise load, les objets chargés sont importés directement dans l’environnement en cours avec leur nom d’origine. Si d’autres objets du même nom existaient déjà, ils sont écrasés sans avertissement. 5.6 Exercices 5.6.1 Sujet Dans ce qui suit on va utiliser des jeux de données correspondant aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. La base de données est répartie en plusieurs tables. Nous allons utiliser une d’entres elles pour le moment à savoir le fichier flights.csv qui présente 336 776 vols sur 19 variables Voici une description de cette table : year, month, day : date du vol. dep_time, arr_time : Heures de départ et d’arrivée réelles (format HHMM ou HMM). sched_dep_time,sched_arr_time : Heures de départ et d’arrivée prévues (format HHMM ou HMM). dep_delay, arr_delay : Retards de départ et d’arrivée, en minutes. Les temps négatifs représentent des départs / arrivées précoces. carrier : Abréviation à deux lettres des compagnies aériennes. flights : Numéro de vol tailnum : Immatriculation de l’avion origine, dest : Aéroport de départ et destination. air_time : Durée du vol en minutes. distance : Distance entre les aéroports, en miles. hour , minute : Heure de départ prévue divisée en heures et minutes. time_hour : Date et heure prévues du vol Exercice 1 Importez le jeu de données fligths.csv Combien de lignes, colonnes sont présentes dans cette table ? Affichez le nom des colonnes Affichez les 10 premières lignes dans une vue Exercice 2 Affichez un résumé des données Affichez le type des colonnes Transformer la variable flighten caractère Affichez les quartiles de la distribution de la variable arr_delay Affichez les déciles de la distribution de la variable distance Exercice 3 Quel est l’aéroport avec le plus de départ en 2013 ? Avec la fonction unique, affichez le nombre de destinations différentes Proposez une représentation graphique adaptée pour la variable arr_delay Proposez une représentation graphique adaptée pour la variable origin Proposez une représentation graphique adaptée pour la variable dest Même question, mais en affichant uniquement un top 10 5.6.2 Correction Exercice 1 Importez le jeu de données fligths.csv flights &lt;- read.csv(file = &quot;./dataset/flights.csv&quot;, sep = &quot;\\t&quot;) Combien de lignes, colonnes sont présentes dans cette table ? dim(x = flights) ## [1] 336776 19 #ou ncol(x = flights) ; nrow(x = flights) ## [1] 19 ## [1] 336776 Affichez le nom des colonnes colnames(x = flights) #fonctionne aussi avec names(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; Affichez les 10 premières lignes dans une vue View(head(x = flights, n = 10)) Exercice 2 Affichez un résumé des données summary(object = flights) Affichez le type des colonnes str(flights) Transformer la variable flighten caractère flights$flight &lt;- as.character(x = flights$flight) class(x = flights$flight ) ## [1] &quot;character&quot; Affichez les quartiles de la distribution de la variable arr_delay #Attention aux valeurs manquantes quantile(x = flights$arr_delay, na.rm = TRUE) ## 0% 25% 50% 75% 100% ## -86 -17 -5 14 1272 Affichez les déciles de la distribution de la variable distance quantile(x = flights$distance, probs = seq(0,1,0.1)) ## 0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% ## 17 214 427 544 733 872 1023 1096 1598 2446 4983 Exercice 3 Quel est l’aéroport avec le plus de départ en 2013 ? table(x = flights$origin) ## x ## EWR JFK LGA ## 120835 111279 104662 Avec la fonction unique, affichez le nombre de destinations différentes length(x = unique(x = flights$dest)) ## [1] 105 Si la variable dest est de type factor, on peut simplement compter le nombre de levels is.factor(flights$dest) ## [1] TRUE length(levels(flights$dest)) ## [1] 105 Proposez une représentation graphique adaptée pour la variable arr_delay boxplot(x = flights$arr_delay, horizontal = TRUE, main = &quot;Répartition des retards (en minutes)&quot;) Proposez une représentation graphique adaptée pour la variable origin count &lt;- table(flights$origin) pie(x = count, main = &quot;Répartition des vols depuis l&#39;aéroport de départ&quot;, labels = paste(row.names(count),&quot;\\n&quot;,count),col = colors()) Proposez une représentation graphique adaptée pour la variable dest count &lt;- sort(x = table(flights$dest),decreasing = TRUE) barplot(height = count, main = &quot;Nombre de vols pour chaque destination&quot;, las = 2, cex.names = 0.4) Même question, mais en affichant uniquement un top 10 count &lt;- sort(x = table(flights$dest),decreasing = TRUE)[1:10] barplot(height = count, main = &quot;Nombre de vols pour chaque destination \\n TOP 10&quot;, ylim = c(0,20000), col = &quot;blue&quot;) feather est un format compatible avec Python, R et Julia. Pour plus d’informations, voir https://github.com/wesm/feather↩ "]
]
