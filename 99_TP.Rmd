# S'entrainer {#entrainement}

## TP1

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
library(dplyr)
library(knitr)
library(kableExtra)
taille <- 12
```

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 et 3.
On utilise  le dataset `mtcars` qui d√©crit les statistiques de voitures.
Le dataset est pr√©sent dans le package *datasets* automatiquement install√© sur R. Voici une description des donn√©es :

-	`mpg`	: Miles/(US) gallon
-	`cyl`	: Number of cylinders
-	`disp` :	Displacement (cu.in.)
-	`hp` :	Gross horsepower
-	`drat` :	Rear axle ratio
-	`wt` :	Weight (1000 lbs)
-	`qsec` :	1/4 mile time
-	`vs` :	Engine (0 = V-shaped, 1 = straight)
-	`am` :	Transmission (0 = automatic, 1 = manual)
-	`gear` :	Number of forward gears
-	`carb` :	Number of carburetors

```{r, echo=FALSE, warning=FALSE, message=FALSE}
df <- mtcars
kable(head(df,n = 10), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```

<br>

**Exercice 1 : Pr√©parer son environnement de travail**

a. Dupliquer le dataset dans un nouvel objet appel√© `df`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Affichez le nom des colonnes
d. Affichez le type des colonnes avec la fonction adapt√©e.
e. On souhaite analyser les variables `cyl`, `vs`, `am`, `gear` et `carb` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont pr√©sents dans ces variables ?
g. Affichez un r√©sum√© des donn√©es avec la fonction adapt√©e.

**Exercice 2 : Statistiques descriptives**

a. D√©terminer la moyenne de la variable `mpg`
b. D√©terminer le maximum la variable `wt`.
c. D√©terminer la m√©diane de la variable `hp`.
d. D√©terminer les quartiles de la variable `qsec`.
e. D√©terminer les d√©ciles de la variable `qsec`.
f. D√©terminer la variance et l'√©cart-type de la variable `qsec`.
g. D√©terminer un tri √† plat pour compter les effectifs des modalit√©s de chaque variables *factor*.

**Exercice 3 : Quelques graphiques**

a. Contruire un histogramme de la distribution de la variable `qsec`.
b. Constuire une bo√Æte √† moustache de la distribution de la variable `qsec`.
c. Construire un diagramme en barre de r√©partition de la variable `carb`.
d. Construire un diagramme circulaire de la r√©partition de la variable `vs`.

**Exercice 4 : Cr√©ation de nouvelles colonnes**

a. La colonne `mpg` correspond au nombre de miles parcouru en 1 gallon (US). Cette mesure correspond en quelques sortes √† la mesure de consommation de litres aux 100 km utilis√©e en France. Cr√©er une colonne suppl√©mentaire appel√©e `litres_au_100km` qui correspond √† la conversion de la variable `mpg`(Miles/(US) gallon) en nombre de litres aux 100 kilom√®tres. Aidez-vous du guide des conversion disponible sur ce [lien](https://anglais-pratique.fr/index.php/rubriques/divers/101-mpg-l-100km).
b. Construire une nouvelle colonne appel√©e `qsec_cut` qui est un d√©coupage de la variable `qsec` en 3 groupes (pas de restriction sur le nombre de classe).
c. Construire une nouvelle colonne appel√©e `litres100km_group` pour distinguer deux groupes de voiture : celles qui consomment plus que la moyenne et celles qui consomment moins que la moyenne.

## TP2


<p>
![Pokemo*](./img/pokemon.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 2 √† 5.
On utilise  le fichier `pokemon.xlsx` qui d√©crit les statistiques des pokemon des deux premi√®res g√©n√©rations.
Le fichier est issu du site [ Kaggle ](https://www.kaggle.com/rounakbanik/pokemon). Il a √©t√© adapt√© pour ce TP. Voici une description des donn√©es :

- `pokedex_number` : num√©ro du pokemon
- `nom` : nom du pokemon
- `generation` : le num√©ro de g√©n√©ration dont est issu le pokemon
- `is_legendary` : Oui / Non si le pokemon est l√©gendaire
- `type` : le type du pokemon
- `weight_kg` : le poids du pokemon en kg
- `height_m` : la taille du pokemon en m√®tre
- `attack` : la puissance d'attaque du pokemon
- `defense` : la puissance de d√©fense du pokemon
- `speed` : la vitesse du pokemon


```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
pokemon <- read_excel(path = "./dataset/pokemon.xlsx", sheet = "pokemon")
kable(head(pokemon,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Importer les donn√©es**

a. Importez le jeu de donn√©es `pokemon.xlsx` √† l'aide du package `readxl`.
b. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?
c. Affichez le nom des colonnes.
d. Affichez le type des colonnes avec la fonction adapt√©e.
e. On souhaite analyser les variables `generation`, `is_legendary`, et `type` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont pr√©sents dans ces variables ?
g. Affichez un r√©sum√© des donn√©es avec la fonction adapt√©e.


**Exercice 2 : Statistiques descriptives**

a. D√©terminer la moyenne de la variable `weight_kg`.
b. D√©terminer la m√©diane de la variable `weight_kg`.
d. D√©terminer les quartiles de la variable `height_m`.
e. D√©terminer les d√©ciles de la variable `height_m`.
f. D√©terminer la variance et l'√©cart-type de la variable `weight_kg`.
g. D√©terminer un tri √† plat pour compter les effectifs des modalit√©s de chaque variable *factor* en triant chaque sortie par ordre d√©croissant.

**Exercice 3 : Tris et Selections**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Exemple :

```{r}
#Selectionnez les deux premi√®res colonnes du data frame
requete_0 <- pokemon[,1:2]
dim(requete_0)
```

a. S√©lectionnez la colonne `nom` et `is_legendary`.
b. S√©lectionnez les 50 premi√®res lignes et les deux premi√®res colonnes.
c. S√©lectionnez les 10 premi√®res lignes et toutes les colonnes.
d. S√©lectionnez toutes les colonnes sauf la derni√®re.
e. S√©lectionnez les colonnes 2,8,9 et 10.
f. S√©lectionnez les lignes 20 √† 30 et 80 √† 100.
g. Triez le dataset  par ordre alphab√©tique et afficher le `nom` du pokemon dela premi√®re ligne.
h. Triez le dataset  par `weight_kg` en ordre **d√©croissant**, et afficher le `nom`du pokemon de la premi√®re ligne
i. Triez le dataset  par `attack` en ordre **d√©croissant** puis par `speed` en ordre **croissant**, et afficher le `nom` des pokemons des 10 premi√®res lignes.


**Exercice 4 : Tris et Filtres**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Pour faciliter la lecture, s√©lectionnez la colonne `nom`et les colonnes concern√©es par le filtre. Exemple :

```{r}
#Selectionnez les pokemons de type feu
requete_0 <- pokemon[ pokemon$type == "fire", c("nom","type")]
dim(requete_0)
```
a. Filtrez sur les pokemons qui ont 150 ou plus d'`attack` puis trier le r√©sultat par ordre d√©croissant d'`attack`. 
b. Filtrez sur les pokemons de `type` *dragon*,*ghost*,*psychic* et *dark*
c. Filtrez sur les pokemons de `type` *fire* avec plus de 100 d'`attack`, puis trier le r√©sultat par ordre d√©croissant d'`attack`. 
d. Filtrez sur les pokemons qui ont entre 100 et 150 de `speed`. Les trier par `speed`d√©croissant.
e. Filtrez sur les pokemons pesant plus de 250 kg et affichez le r√©sultat pour v√©rifier.
f. Filtrez sur les pok√©mons qui ont des valeurs manquantes sur la variable `height_m`.
g. Filtrez sur les pokemons qui ont des valeurs renseign√©es √† la fois pour la variable `weight_kg` **et** la variable `height`.


**Exercice 5 : Agregations**

Pour chaque question suivante, affectez le r√©sultat de la requ√™te dans un objet puis calculez sa dimension. Exemple :

```{r}
#Calculez la vitesse moyenne par generation
requete_0 <- aggregate(formula = speed ~ generation, data = pokemon , FUN = mean)
dim(requete_0)
```

```{r, echo=FALSE}
kable(requete_0)
```

a. Calculez l'`attack` moyenne en fonction de la variable `type`, puis filtrez sur les 3 types avec les moyennes les plus √©lev√©es.
b. Calculez le nombre de pokemon par `type` , puis triez par ordre d√©croissant ces effectifs.
c. Calculez la m√©diane de `weight_kg` par `type`.
d. Calculez le nombre de pokemon par `type` et `generation`
e. Calculez la moyenne de chaque crit√®re (`weight_kg`, `height_m`, `attack`, `defense` et `speed`) en fonction de chaque `type`.

## TP3

<p>
![Among us*](./img/amongus.jpg)
</p>

Ce TP reprend les notions √©voqu√©es dans les chapitres 6,7 et 10.
On utilise  les fichiers d√©crivant les statistiques des parties jou√©es sur le jeu *Among us*. Il y a un fichier par joueur nomm√© *UserX.csv*.
Les fichiers sont issues du site [Kaggle](https://www.kaggle.com/ruchi798/among-us-dataset).
Les fichiers ont tous la m√™me structure avec :

- `Game.Completed.Date` : Date de la partie
- `Team` : l'√©quipe attribu√©e
- `Outcome` : r√©sultat de la partie
- `Task.Completed` : le nombre de t√¢ches effectu√©es
- `All.Tasks.Completed` : si toutes les t√¢ches ont √©t√© effectu√©es
- `Murdered` : si le joueur a √©t√© tu√©
- `Imposter.Kills` : le nombre de joueurs tu√©s par l'imposteur
- `Game.Length` : dur√©e de la partie
- `Ejected` : si le joueur a √©t√© √©limin√© par les autres au cours de la partie
- `Sabotages.Fixed` : nombre de sabotages r√©par√©s
- `Time.to.complete.all.tasks` : temps pour compl√©ter les toutes les t√¢ches
- `Rank.Change`  : Non renseign√©
- `Region.Game.Code` : la r√©gion du serveur de jeu


```{r, echo=FALSE, warning=FALSE, message=FALSE}
AmongUs <-read.csv("./dataset/AmongUs.csv")
kable(head(AmongUs,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Cr√©er le jeu de donn√©es**

a. T√©l√©charger le fichier compr√©ss√© `AmongUs.7z` et d√©zip√© le. La fonction `list.files()` devrait vous aider √† extraire l'ensemble des noms de fichiers pr√©sents dans un r√©pertoire (voir exemple ci-dessous).

```{r}
list.files(path = "./dataset/", pattern="*.csv", full.names=FALSE)
```

b. Compiler l'ensemble des fichiers *UserX.csv* pr√©sents dans le fichier zip dans un seul et m√™me data frame. Utilisez une boucle qui parcourt chaque fichier csv utilisateur. 

c. Modifier votre boucle afin d'ajouter une colonne dans le data frame final qui renseigne le num√©ro d'utilisateur disponible dans le nom de chaque fichier csv.

d. Stocker le data frame final dans un objet appel√© *AmongUs*.

e. Supprimer la colonne `Rank.Change` qui est inutile.

f. Construire une fonction appel√© `manage_na()` qui prend en entr√©e un vecteur `x` correspondant aux donn√©es et un vecteur `string_to_na` correspondant √† la liste des cha√Ænes de caract√®res qu'on souhaite transformer en `NA`. La fonction retournera le vecteur modifi√©.

g. Construire une boucle qui parcourt toutes les colonnes du data frame *AmongUs* et qui remplace les champs avec des `-` et `N/A` par des valeurs manquantes `NA`. Utilisez la fonction `manage_na()` cr√©√©e pr√©c√©demment.


**Exercice 2 : Manipuler le texte et les dates**

a. √Ä partir de la colonne `Game.Completed.Date`, construire une colonne appel√©e `Date` avec la date de la partie au format *yyyy-mm-dd*. V√©rifiez que la colonne est bien en type *Date*.

b. √Ä partir de la colonne `Game.Completed.Date`, construire une colonne appel√©e `Heure` avec **l'heure uniquement** de la partie. Attention au format *am* et *pm*. Veillez √† ce que le type de cette colonne soit `numeric`.

c. √Ä partir de la colonne `Game Length`, construire une colonne appel√©e `Game.Length.sec` correspondant √† la dur√©e de la partie en secondes

d. √Ä partir de la colonne `Time.to.complete.all.tasks`, construire une colonne appel√©e `Complete.all.tasks.sec` correspondant √† la dur√©e en secondes pour compl√©ter toutes les t√¢ches.

e. √Ä partir de la colonne `Region.Game.Code` construire une colonne appel√©e `Region` correspondant au nom du continent uniquement. Veillez √† ce que cette nouvelle colonne soit en type `factor`.

**Exercice 3 : Type des variables**

a. Combien de lignes, colonnes sont pr√©sentes dans ce dataset (utilisez les fonctions adapt√©es) ?

b. Affichez un r√©sum√© des donn√©es avec la fonction adapt√©e. On remarque que les colonnes `Game.Completed.Date`, `Game.Length`, `Time.to.complete.all.tasks` et `Region.Game.Code` sont en `factor`.

c. Construire une boucle qui parcourt les 4 colonnes cit√©es dans la question pr√©c√©dente pour les convertir en type `character` l'une apr√®s l'autre.

d. V√©rifier si cela a fonctionn√© en affichant le type de chaque variable du data frame.
 
e. Les autres variables qualitatives doivent √™tre en `factor`. Si ce n'est pas le cas, contruire une boucle qui les convertit en `factor` les unes apr√®s les autres.
 
**Exercice 4 : Analyses statistiques **

La plupart des questions de cet exercice demandent un peu de r√©flexion. <br>
üì¢ Ne partez pas √† l'abordage, les solutions peuvent se coder en plusieurs √©tapes (*tris*,*filtre*, *agregation*, *etc.*).

a. Quelle est la dur√©e moyenne d'une partie ? 

b. Combien y-a-t-il de r√©gions serveurs diff√©rentes ?.

c. Combien de t√¢che maximum un Crewmate peut-il r√©aliser ?

d. Quel est le taux de parties remport√©es par les imposteurs ?

e. Construire **un graphique adapt√©** permettant de visualiser la r√©partition du nombre de parties jou√©es selon la`Region`.

f. Constuire **un graphique adapt√©** permettant de visualiser la r√©partition des joueurs qui termine ou pas leur t√¢ches selon s'ils se font tuer ou pas.

g. Construire **un graphique adapt√©** permettant de visualiser la distribution du nombre de t√¢ches compl√©t√©es par les joueurs.

h. Construire **un graphique adapt√©** permettant de visualiser pour chaque partie jou√©e, la dur√©e de la partie et le temps pour compl√©ter toutes les t√¢ches.

i. Construire **un graphique adapt√©** permettant de visualiser la distribution du temps des parties selon la `Region`.

j. Construire **un graphique adapt√©** permettant de visualiser l'√©volution du nombre de parties jou√©es selon l'heure de la journ√©e.

k. Constuire **un graphique adapt√©** permettant de visualiser les variations de taux de succ√®s des imposteurs selon les r√©gions serveurs.

l. Constuire **un graphique adapt√©** permettant de visualiser les taux de succ√®s  des 5 meilleurs utilisateurs.