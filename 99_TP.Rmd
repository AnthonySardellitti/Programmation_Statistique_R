# S'entrainer {#entrainement}

## TP1

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
library(dplyr)
library(knitr)
library(kableExtra)
taille <- 12
```

Ce TP reprend les notions évoquées dans les chapitres 2 et 3.
On utilise  le dataset `mtcars` qui décrit les statistiques de voitures.
Le dataset est présent dans le package *datasets* automatiquement installé sur R. Voici une description des données :

-	`mpg`	: Miles/(US) gallon
-	`cyl`	: Number of cylinders
-	`disp` :	Displacement (cu.in.)
-	`hp` :	Gross horsepower
-	`drat` :	Rear axle ratio
-	`wt` :	Weight (1000 lbs)
-	`qsec` :	1/4 mile time
-	`vs` :	Engine (0 = V-shaped, 1 = straight)
-	`am` :	Transmission (0 = automatic, 1 = manual)
-	`gear` :	Number of forward gears
-	`carb` :	Number of carburetors

```{r, echo=FALSE, warning=FALSE, message=FALSE}
df <- mtcars
kable(head(df,n = 10), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```

<br>

**Exercice 1 : Préparer son environnement de travail**

a. Dupliquer le dataset dans un nouvel objet appelé `df`.
b. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ?
c. Affichez le nom des colonnes
d. Affichez le type des colonnes avec la fonction adaptée.
e. On souhaite analyser les variables `cyl`, `vs`, `am`, `gear` et `carb` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont présents dans ces variables ?
g. Affichez un résumé des données avec la fonction adaptée.

**Exercice 2 : Statistiques descriptives**

a. Déterminer la moyenne de la variable `mpg`
b. Déterminer le maximum la variable `wt`.
c. Déterminer la médiane de la variable `hp`.
d. Déterminer les quartiles de la variable `qsec`.
e. Déterminer les déciles de la variable `qsec`.
f. Déterminer la variance et l'écart-type de la variable `qsec`.
g. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variables *factor*.

**Exercice 3 : Quelques graphiques**

a. Contruire un histogramme de la distribution de la variable `qsec`.
b. Constuire une boîte à moustache de la distribution de la variable `qsec`.
c. Construire un diagramme en barre de répartition de la variable `carb`.
d. Construire un diagramme circulaire de la répartition de la variable `vs`.

**Exercice 4 : Création de nouvelles colonnes**

a. La colonne `mpg` correspond au nombre de miles parcouru en 1 gallon (US). Cette mesure correspond en quelques sortes à la mesure de consommation de litres aux 100 km utilisée en France. Créer une colonne supplémentaire appelée `litres_au_100km` qui correspond à la conversion de la variable `mpg`(Miles/(US) gallon) en nombre de litres aux 100 kilomètres. Aidez-vous du guide des conversion disponible sur ce [lien](https://anglais-pratique.fr/index.php/rubriques/divers/101-mpg-l-100km).
b. Construire une nouvelle colonne appelée `qsec_cut` qui est un découpage de la variable `qsec` en 3 groupes (pas de restriction sur le nombre de classe).
c. Construire une nouvelle colonne appelée `litres100km_group` pour distinguer deux groupes de voiture : celles qui consomment plus que la moyenne et celles qui consomment moins que la moyenne.

## TP2


<p>
![Pokemo*](./img/pokemon.jpg)
</p>

Ce TP reprend les notions évoquées dans les chapitres 2 à 5.
On utilise  le fichier `pokemon.xlsx` qui décrit les statistiques des pokemon des deux premières générations.
Le fichier est issu du site [ Kaggle ](https://www.kaggle.com/rounakbanik/pokemon). Il a été adapté pour ce TP. Voici une description des données :

- `pokedex_number` : numéro du pokemon
- `nom` : nom du pokemon
- `generation` : le numéro de génération dont est issu le pokemon
- `is_legendary` : Oui / Non si le pokemon est légendaire
- `type` : le type du pokemon
- `weight_kg` : le poids du pokemon en kg
- `height_m` : la taille du pokemon en mètre
- `attack` : la puissance d'attaque du pokemon
- `defense` : la puissance de défense du pokemon
- `speed` : la vitesse du pokemon


```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readxl)
pokemon <- read_excel(path = "./dataset/pokemon.xlsx", sheet = "pokemon")
kable(head(pokemon,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Importer les données**

a. Importez le jeu de données `pokemon.xlsx` à l'aide du package `readxl`.
b. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ?
c. Affichez le nom des colonnes.
d. Affichez le type des colonnes avec la fonction adaptée.
e. On souhaite analyser les variables `generation`, `is_legendary`, et `type` en tant que variables qualitatives. Modifier le type de ces variables pour les transformer en type factor.
f. Combien de niveaux (*levels*) sont présents dans ces variables ?
g. Affichez un résumé des données avec la fonction adaptée.


**Exercice 2 : Statistiques descriptives**

a. Déterminer la moyenne de la variable `weight_kg`.
b. Déterminer la médiane de la variable `weight_kg`.
d. Déterminer les quartiles de la variable `height_m`.
e. Déterminer les déciles de la variable `height_m`.
f. Déterminer la variance et l'écart-type de la variable `weight_kg`.
g. Déterminer un tri à plat pour compter les effectifs des modalités de chaque variable *factor* en triant chaque sortie par ordre décroissant.

**Exercice 3 : Tris et Selections**

Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple :

```{r}
#Selectionnez les deux premières colonnes du data frame
requete_0 <- pokemon[,1:2]
dim(requete_0)
```

a. Sélectionnez la colonne `nom` et `is_legendary`.
b. Sélectionnez les 50 premières lignes et les deux premières colonnes.
c. Sélectionnez les 10 premières lignes et toutes les colonnes.
d. Sélectionnez toutes les colonnes sauf la dernière.
e. Sélectionnez les colonnes 2,8,9 et 10.
f. Sélectionnez les lignes 20 à 30 et 80 à 100.
g. Triez le dataset  par ordre alphabétique et afficher le `nom` du pokemon dela première ligne.
h. Triez le dataset  par `weight_kg` en ordre **décroissant**, et afficher le `nom`du pokemon de la première ligne
i. Triez le dataset  par `attack` en ordre **décroissant** puis par `speed` en ordre **croissant**, et afficher le `nom` des pokemons des 10 premières lignes.


**Exercice 4 : Tris et Filtres**

Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Pour faciliter la lecture, sélectionnez la colonne `nom`et les colonnes concernées par le filtre. Exemple :

```{r}
#Selectionnez les pokemons de type feu
requete_0 <- pokemon[ pokemon$type == "fire", c("nom","type")]
dim(requete_0)
```
a. Filtrez sur les pokemons qui ont 150 ou plus d'`attack` puis trier le résultat par ordre décroissant d'`attack`. 
b. Filtrez sur les pokemons de `type` *dragon*,*ghost*,*psychic* et *dark*
c. Filtrez sur les pokemons de `type` *fire* avec plus de 100 d'`attack`, puis trier le résultat par ordre décroissant d'`attack`. 
d. Filtrez sur les pokemons qui ont entre 100 et 150 de `speed`. Les trier par `speed`décroissant.
e. Filtrez sur les pokemons pesant plus de 250 kg et affichez le résultat pour vérifier.
f. Filtrez sur les pokémons qui ont des valeurs manquantes sur la variable `height_m`.
g. Filtrez sur les pokemons qui ont des valeurs renseignées à la fois pour la variable `weight_kg` **et** la variable `height`.


**Exercice 5 : Agregations**

Pour chaque question suivante, affectez le résultat de la requête dans un objet puis calculez sa dimension. Exemple :

```{r}
#Calculez la vitesse moyenne par generation
requete_0 <- aggregate(formula = speed ~ generation, data = pokemon , FUN = mean)
dim(requete_0)
```

```{r, echo=FALSE}
kable(requete_0)
```

a. Calculez l'`attack` moyenne en fonction de la variable `type`, puis filtrez sur les 3 types avec les moyennes les plus élevées.
b. Calculez le nombre de pokemon par `type` , puis triez par ordre décroissant ces effectifs.
c. Calculez la médiane de `weight_kg` par `type`.
d. Calculez le nombre de pokemon par `type` et `generation`
e. Calculez la moyenne de chaque critère (`weight_kg`, `height_m`, `attack`, `defense` et `speed`) en fonction de chaque `type`.

## TP3

<p>
![Among us*](./img/amongus.jpg)
</p>

Ce TP reprend les notions évoquées dans les chapitres 6,7 et 10.
On utilise  les fichiers décrivant les statistiques des parties jouées sur le jeu *Among us*. Il y a un fichier par joueur nommé *UserX.csv*.
Les fichiers sont issues du site [Kaggle](https://www.kaggle.com/ruchi798/among-us-dataset).
Les fichiers ont tous la même structure avec :

- `Game.Completed.Date` : Date de la partie
- `Team` : l'équipe attribuée
- `Outcome` : résultat de la partie
- `Task.Completed` : le nombre de tâches effectuées
- `All.Tasks.Completed` : si toutes les tâches ont été effectuées
- `Murdered` : si le joueur a été tué
- `Imposter.Kills` : le nombre de joueurs tués par l'imposteur
- `Game.Length` : durée de la partie
- `Ejected` : si le joueur a été éliminé par les autres au cours de la partie
- `Sabotages.Fixed` : nombre de sabotages réparés
- `Time.to.complete.all.tasks` : temps pour compléter les toutes les tâches
- `Rank.Change`  : Non renseigné
- `Region.Game.Code` : la région du serveur de jeu


```{r, echo=FALSE, warning=FALSE, message=FALSE}
AmongUs <-read.csv("./dataset/AmongUs.csv")
kable(head(AmongUs,n = 20), "html") %>% kable_styling("striped", font_size = taille) %>% scroll_box(width = "100%", height = "400px")
```
<br>

**Exercice 1 : Créer le jeu de données**

a. Télécharger le fichier compréssé `AmongUs.7z` et dézipé le. La fonction `list.files()` devrait vous aider à extraire l'ensemble des noms de fichiers présents dans un répertoire (voir exemple ci-dessous).

```{r}
list.files(path = "./dataset/", pattern="*.csv", full.names=FALSE)
```

b. Compiler l'ensemble des fichiers *UserX.csv* présents dans le fichier zip dans un seul et même data frame. Utilisez une boucle qui parcourt chaque fichier csv utilisateur. 

c. Modifier votre boucle afin d'ajouter une colonne dans le data frame final qui renseigne le numéro d'utilisateur disponible dans le nom de chaque fichier csv.

d. Stocker le data frame final dans un objet appelé *AmongUs*.

e. Supprimer la colonne `Rank.Change` qui est inutile.

f. Construire une fonction appelé `manage_na()` qui prend en entrée un vecteur `x` correspondant aux données et un vecteur `string_to_na` correspondant à la liste des chaînes de caractères qu'on souhaite transformer en `NA`. La fonction retournera le vecteur modifié.

g. Construire une boucle qui parcourt toutes les colonnes du data frame *AmongUs* et qui remplace les champs avec des `-` et `N/A` par des valeurs manquantes `NA`. Utilisez la fonction `manage_na()` créée précédemment.


**Exercice 2 : Manipuler le texte et les dates**

a. À partir de la colonne `Game.Completed.Date`, construire une colonne appelée `Date` avec la date de la partie au format *yyyy-mm-dd*. Vérifiez que la colonne est bien en type *Date*.

b. À partir de la colonne `Game.Completed.Date`, construire une colonne appelée `Heure` avec **l'heure uniquement** de la partie. Attention au format *am* et *pm*. Veillez à ce que le type de cette colonne soit `numeric`.

c. À partir de la colonne `Game Length`, construire une colonne appelée `Game.Length.sec` correspondant à la durée de la partie en secondes

d. À partir de la colonne `Time.to.complete.all.tasks`, construire une colonne appelée `Complete.all.tasks.sec` correspondant à la durée en secondes pour compléter toutes les tâches.

e. À partir de la colonne `Region.Game.Code` construire une colonne appelée `Region` correspondant au nom du continent uniquement. Veillez à ce que cette nouvelle colonne soit en type `factor`.

**Exercice 3 : Type des variables**

a. Combien de lignes, colonnes sont présentes dans ce dataset (utilisez les fonctions adaptées) ?

b. Affichez un résumé des données avec la fonction adaptée. On remarque que les colonnes `Game.Completed.Date`, `Game.Length`, `Time.to.complete.all.tasks` et `Region.Game.Code` sont en `factor`.

c. Construire une boucle qui parcourt les 4 colonnes citées dans la question précédente pour les convertir en type `character` l'une après l'autre.

d. Vérifier si cela a fonctionné en affichant le type de chaque variable du data frame.
 
e. Les autres variables qualitatives doivent être en `factor`. Si ce n'est pas le cas, contruire une boucle qui les convertit en `factor` les unes après les autres.
 
**Exercice 4 : Analyses statistiques **

La plupart des questions de cet exercice demandent un peu de réflexion. <br>
📢 Ne partez pas à l'abordage, les solutions peuvent se coder en plusieurs étapes (*tris*,*filtre*, *agregation*, *etc.*).

a. Quelle est la durée moyenne d'une partie ? 

b. Combien y-a-t-il de régions serveurs différentes ?.

c. Combien de tâche maximum un Crewmate peut-il réaliser ?

d. Quel est le taux de parties remportées par les imposteurs ?

e. Construire **un graphique adapté** permettant de visualiser la répartition du nombre de parties jouées selon la`Region`.

f. Constuire **un graphique adapté** permettant de visualiser la répartition des joueurs qui termine ou pas leur tâches selon s'ils se font tuer ou pas.

g. Construire **un graphique adapté** permettant de visualiser la distribution du nombre de tâches complétées par les joueurs.

h. Construire **un graphique adapté** permettant de visualiser pour chaque partie jouée, la durée de la partie et le temps pour compléter toutes les tâches.

i. Construire **un graphique adapté** permettant de visualiser la distribution du temps des parties selon la `Region`.

j. Construire **un graphique adapté** permettant de visualiser l'évolution du nombre de parties jouées selon l'heure de la journée.

k. Constuire **un graphique adapté** permettant de visualiser les variations de taux de succès des imposteurs selon les régions serveurs.

l. Constuire **un graphique adapté** permettant de visualiser les taux de succès  des 5 meilleurs utilisateurs.